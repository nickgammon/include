/*

Support functions, in Javascript, for the DTP system (see /hhs/dtp.php)


Copyright Â© 2019 Nick Gammon.

  Author: Nick Gammon <nick@gammon.com.au>
  Web:    http://www.gammon.com.au/
  Date:   November 2019

 PERMISSION TO DISTRIBUTE

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 and associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 LIMITATION OF LIABILITY

 The software is provided "as is", without warranty of any kind, express or implied,
 including but not limited to the warranties of merchantability, fitness for a particular
 purpose and noninfringement. In no event shall the authors or copyright holders be liable
 for any claim, damages or other liability, whether in an action of contract,
 tort or otherwise, arising from, out of or in connection with the software
 or the use or other dealings in the software.

  Note: The PHP file communicates with this module by passing down variables giving the element ID,
  element type and position of each element. The page width and page height are for converting from
  mm as used in the document and pixels as used on the screen.

  Example:

  var num_elements = 6;
  var page_width = 210;
  var page_height = 297;
  var grid_size_x = 8;
  var grid_size_y = 8;
  var elements = [
  [ 36, 3, 108, 48, 108, 280 ],
  [ 50, 6, 16, 96, 96, 152 ],
  [ 56, 6, 16, 216, 100, 268 ],
  [ 60, 5, 16, 16, 200, 40 ],
  [ 61, 5, 16, 48, 104, 212 ],
  [ 62, 7, 112, 48, 200, 288 ],
  ];

*/

"use strict"

const BOX_SIZE = 10;   // size of corner boxes
const DRAGGING_BOX_SIZE = 30;  // width of globals.dragging box (height is BOX_SIZE)
const BOX_OPACITY = 1;
const BACKGROUND_OPACITY = 0.15;
const BACKGROUND_COLOUR = 'black';

// array position meanings (as generated by dtp.php)
const ELEMENT_ID    = 0;
const ELEMENT_TYPE  = 1;
const STARTX        = 2;
const STARTY        = 3;
const ENDX          = 4;
const ENDY          = 5;

const LAST_ITEM = ENDY;  // must be last element in array (above)

// element types
const ELEMENT_RECTANGLE         = 1;
const ELEMENT_ELLIPSE           = 2;
const ELEMENT_LINE              = 3;
const ELEMENT_STAR              = 4;
const ELEMENT_TEXT              = 5;
const ELEMENT_IMAGE             = 6;
const ELEMENT_TEXT_CONTINUATION = 7;

// for the page grid
const GRID_SIZE_X = 8;
const GRID_SIZE_Y = 8;

// put our global variables here to make it clear they are global
var globals = [];

// Initialization: called on load of script
function init()
  {
  globals.canvas = document.getElementById("mycanvas");  // our globals.canvas

  if (globals.canvas)
    {
    globals.ctx = globals.canvas.getContext("2d");                 // our drawing context
    // convert width from mm into pixels as displayed on the page
    globals.width_multiple  = globals.canvas.width / page_width;
    globals.height_multiple = globals.canvas.height / page_height;

    // make a copy of element positions so we can reset to the beginning state
    globals.orig_elements = [];
    for (var i = 0; i < num_elements; i++)
      {
      globals.orig_elements [i] = [];
      for (var j = 0; j <= LAST_ITEM; j++)
        globals.orig_elements [i] [j] = elements [i] [j];
      }
    } // end of if globals.canvas exists

  // they haven't clicked the "Edit" button yet
  globals.edit_clicked = false;
  globals.edits_done   = false;
  globals.dragging     = false;

  submit_edits_button = document.getElementById("submit_edits_button");
  submit_edits_button.onclick = SubmitEditsClicked;
  } // end of init

// draw one of the four corner boxes
function drawCornerBox (x, y)
  {
  globals.ctx.beginPath();
  globals.ctx.rect((x * globals.width_multiple)   - BOX_SIZE / 2,
           (y * globals.height_multiple)  - BOX_SIZE / 2,
           BOX_SIZE,
           BOX_SIZE
           );
  globals.ctx.fillStyle = "green";
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.fill ();
  } // end of drawCornerBox

// fill with different colours to make the different elements stand out from each other
var movedFillColours = [
  'Red',
  'Green',
  'Blue',
  'Cyan',
  'Magenta',
  'Yellow',
  'Black',
];

// extract out one array element into global variables
function getElementDetails (element)
  {
  // extract out fields from database
  globals.element_id    = element [ELEMENT_ID];
  globals.element_type  = element [ELEMENT_TYPE];
  globals.startX        = element [STARTX];
  globals.startY        = element [STARTY];
  globals.endX          = element [ENDX];
  globals.endY          = element [ENDY];

  } // end of getElementDetails

// draw element borders, plus resizing and moving handles
function drawborders ()
{
globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas
for (var i = 0; i < num_elements; i++)
  {
  // get *this* element
  getElementDetails (elements [i]);

  // stroke the entire element (box around it)
  globals.ctx.beginPath();
  globals.ctx.rect(globals.startX * globals.width_multiple, globals.startY * globals.height_multiple,
                  (globals.endX - globals.startX) * globals.width_multiple, (globals.endY - globals.startY) * globals.height_multiple);

  // fill box if moved from original position
  if (ElementChanged (i))
    {
//    globals.ctx.fillStyle = BACKGROUND_COLOUR;
    globals.ctx.fillStyle = movedFillColours [i % movedFillColours.length];
    globals.ctx.globalAlpha = BACKGROUND_OPACITY;  // low opacity fill
    globals.ctx.globalAlpha = BACKGROUND_OPACITY * (Math.floor (i / movedFillColours.length) + 1);
    globals.ctx.fill();
    }

  // now draw box around it
  globals.ctx.strokeStyle = "green";
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.stroke();

  // corner boxes (small boxes at corners)
  drawCornerBox (globals.startX, globals.startY);

  // lines only have two corners
  if (globals.element_type != ELEMENT_LINE)
    {
    drawCornerBox (globals.endX, globals.startY);
    drawCornerBox (globals.startX, globals.endY);
    }

  drawCornerBox (globals.endX, globals.endY);

  // draw globals.dragging box
  globals.ctx.beginPath();
  var x = globals.startX + ((globals.endX - globals.startX) / 2);  // half way along
  globals.ctx.rect((x * globals.width_multiple) - (DRAGGING_BOX_SIZE / 2),
           (globals.startY * globals.height_multiple)  - BOX_SIZE / 2,
           DRAGGING_BOX_SIZE,
           BOX_SIZE
           );
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.fillStyle = "green";
  globals.ctx.fill ();

  } // end of for each element

} // end of drawborders

// helper function to reset one element back to its original position
function ResetOneElement (which)
  {

  // copy values back
  for (var j = 0; j <= LAST_ITEM; j++)
    elements [which] [j] = globals.orig_elements [which] [j];

  // put the HTML values back
  globals.element_id = elements [which] [ELEMENT_ID];

  // fix up globals.startX
  globals.startXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startX"));
  globals.startXonPage [0].value = elements [which] [STARTX];

  // fix up globals.startY
  globals.startYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startY"));
  globals.startYonPage [0].value = elements [which] [STARTY];

  // fix up globals.endX
  globals.endXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endX"));
  globals.endXonPage [0].value = elements [which] [ENDX];

  // fix up globals.endY
  globals.endYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endY"));
  globals.endYonPage [0].value = elements [which] [ENDY];

  } // end of ResetOneElement

// here when the "Reset" button clicked - put everything back to how it was
function ResetClicked (event)
{
  submit_edits_button = document.getElementById("submit_edits_button");
  submit_edits_button.disabled = true;

  reset_edits_button = document.getElementById("reset_edits_button");
  reset_edits_button.disabled = true;

  // reset all elements
  for (var i = 0; i < num_elements; i++)
    ResetOneElement (i);

  drawborders ();   // redraw original positions
  globals.edits_done = false;
  return false;     // don't submit form
} // end of ResetClicked

// here when the "Edit" / "Submit edits" button is clicked
function SubmitEditsClicked (event)
{
  if (!globals.edit_clicked)
    {
    globals.edit_clicked          = true;
    submit_edits_button           = document.getElementById("submit_edits_button");
    submit_edits_button.value     = "Submit edits";
    submit_edits_button.disabled  = true;  // nothing edited yet
    drawborders ();
    return false;   // don't submit yet
    }
  return true;  // submit form now
} // end of SubmitEditsClicked

// returns true if this element has globals.changed from its original position
function ElementChanged (which)
  {
  return elements [which] [STARTX] != globals.orig_elements [which] [STARTX] ||
         elements [which] [ENDX]   != globals.orig_elements [which] [ENDX] ||
         elements [which] [STARTY] != globals.orig_elements [which] [STARTY] ||
         elements [which] [ENDY]   != globals.orig_elements [which] [ENDY];
  } // end of ElementChanged

// see if the page has globals.changed by checking all elements
function CheckIfPageChanged ()
  {
  globals.changed = false;  // no changes yet

  // check each element
  for (var i = 0; i < num_elements; i++)
    if (ElementChanged (i))
      globals.changed = true;

  if (globals.changed)
    {
    submit_edits_button.disabled  = false;
    reset_edits_button.disabled   = false;
    reset_edits_button.onclick    = ResetClicked;
    globals.edits_done            = true;
    }
  else
    {
    // no changes? make sure submit and reset buttons are disabled
    // - this is for the situation where you make a change and then change it back
    submit_edits_button.disabled  = true;
    reset_edits_button.disabled   = true;
    reset_edits_button.onclick    = null;
    globals.edits_done            = false;
    }
  } // end of CheckIfPageChanged

// set the appropriate mouse cursor shape depending on what it is hovering over, if anything
function SetMouseCursor (event)
  {
  var mousex = event.offsetX;
  var mousey = event.offsetY;

  // find active element, assuming we can see them (edit button has been clicked)
  if (globals.edit_clicked)
    {
    for (var i = 0; i < num_elements; i++)
      {
      globals.activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);
      // top left?
      if (mouseInBox (mousex, mousey, globals.startX, globals.startY, BOX_SIZE, BOX_SIZE))
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // top right?
      else if (mouseInBox (mousex, mousey, globals.endX, globals.startY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // bottom left?
      else if (mouseInBox (mousex, mousey, globals.startX, globals.endY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // bottom right?
      else if (mouseInBox (mousex, mousey, globals.endX, globals.endY, BOX_SIZE, BOX_SIZE))
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // and now check the globals.dragging box
      else if (mouseInBox (mousex, mousey, globals.startX + (globals.endX - globals.startX) / 2, globals.startY, DRAGGING_BOX_SIZE, BOX_SIZE))
        {
        globals.canvas.style.cursor = 'move';
        return;
        }
      } // end of for each element
    }   // of edit button active

  // edit button or not, we can double-click elements

  // check the entire element rectangle
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    if (mousex < (globals.startX * globals.width_multiple))
      continue;  // too far left
    if (mousex > (globals.endX * globals.width_multiple))
      continue;  // too far right
    if (mousey < (globals.startY * globals.height_multiple))
      continue;  // too far up
    if (mousey > (globals.endY * globals.height_multiple))
      continue;  // too far down

    // globals.found the element!
    globals.canvas.style.cursor = 'pointer';
    return;
    } // end of for each element

  // mouse isn't anywhere interesting
  globals.canvas.style.cursor = 'default';

  } // end of SetMouseCursor

// mouse move handler - resize the element box (or move it) assuming we had a previous mouse down
function onMouseMove(event)
{
  globals.mousex = event.offsetX;
  globals.mousey = event.offsetY;

  // if globals.dragging (mouse down previously) update the element's position depending on where we move to
  if (globals.dragging)
   {
    // find new position in mm
    var x = Math.round(globals.mousex / globals.width_multiple);
    var y = Math.round(globals.mousey / globals.height_multiple);

    // shift key snaps to the grid
    if (event.shiftKey)
      {
      x = Math.round(x / grid_size_x) * grid_size_x;
      y = Math.round(y / grid_size_y) * grid_size_y;
      }

    globals.element_type = elements [globals.activeElement] [ELEMENT_TYPE];

    // update element - depending on which corner was being moved

    // top left
    if (globals.activeCorner == 'topleft' && globals.element_type == ELEMENT_LINE)
      {
      // lines can line up vertically and horizontally
      if (x <= elements [globals.activeElement] [ENDX] && y <= elements [globals.activeElement] [ENDY])
        {
        elements [globals.activeElement] [STARTX] = x;
        elements [globals.activeElement] [STARTY] = y;
        }
      }
    else if (globals.activeCorner == 'topleft' && globals.element_type != ELEMENT_LINE)
      {
      if (x < elements [globals.activeElement] [ENDX] && y < elements [globals.activeElement] [ENDY])
        {
        elements [globals.activeElement] [STARTX] = x;
        elements [globals.activeElement] [STARTY] = y;
        }
      }

    // top right
    else if (globals.activeCorner == 'topright')
      {
      if (x > elements [globals.activeElement] [STARTX] && y < elements [globals.activeElement] [ENDY])
        {
        elements [globals.activeElement] [ENDX] = x;
        elements [globals.activeElement] [STARTY] = y;
        }
      }

    // bottom left
    else if (globals.activeCorner == 'bottomleft')
      {
      if (x < elements [globals.activeElement] [ENDX] && y > elements [globals.activeElement] [STARTY])
        {
        elements [globals.activeElement] [STARTX] = x;
        elements [globals.activeElement] [ENDY] = y;
        }
      }

   // bottom right
   else if (globals.activeCorner == 'bottomright' && globals.element_type == ELEMENT_LINE)
      {
      // lines can line up vertically and horizontally
      if (x >= elements [globals.activeElement] [STARTX] && y >= elements [globals.activeElement] [STARTY])
        {
        elements [globals.activeElement] [ENDX] = x;
        elements [globals.activeElement] [ENDY] = y;
        }
      }
   else if (globals.activeCorner == 'bottomright' && globals.element_type != ELEMENT_LINE)
      {
      if (x > elements [globals.activeElement] [STARTX] && y > elements [globals.activeElement] [STARTY])
        {
        elements [globals.activeElement] [ENDX] = x;
        elements [globals.activeElement] [ENDY] = y;
        }
      }

    // drag box (reposition)
    else if (globals.activeCorner == 'drag')
      {
      var deltaX = Math.round((globals.dragMouseX - event.offsetX) / globals.width_multiple);
      var deltaY = Math.round((globals.dragMouseY - event.offsetY) / globals.height_multiple);

      var new_x = globals.dragStartX - deltaX;
      var new_y = globals.dragStartY - deltaY;
      var width = elements [globals.activeElement]  [ENDX] - elements [globals.activeElement] [STARTX];
      var height = elements [globals.activeElement] [ENDY] - elements [globals.activeElement] [STARTY];

      // shift key snaps to the grid
      if (event.shiftKey)
        {
        new_x = Math.round(new_x / grid_size_x) * grid_size_x;
        new_y = Math.round(new_y / grid_size_y) * grid_size_y;
        }

      elements [globals.activeElement] [STARTX] = new_x;
      elements [globals.activeElement] [STARTY] = new_y;
      elements [globals.activeElement] [ENDX]   = new_x + width;
      elements [globals.activeElement] [ENDY]   = new_y + height;
      }

    drawborders ();

    // update form ready for them to post it

    // turn element array number into an element ID
    globals.element_id = elements [globals.activeElement] [ELEMENT_ID];

    // fix up globals.startX
    globals.startXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startX"));
    globals.startXonPage [0].value = elements [globals.activeElement] [STARTX];

    // fix up globals.startY
    globals.startYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startY"));
    globals.startYonPage [0].value = elements [globals.activeElement] [STARTY];

    // fix up globals.endX
    globals.endXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endX"));
    globals.endXonPage [0].value = elements [globals.activeElement] [ENDX];

    // fix up globals.endY
    globals.endYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endY"));
    globals.endYonPage [0].value = elements [globals.activeElement] [ENDY];

    submit_edits_button = document.getElementById("submit_edits_button");
    reset_edits_button = document.getElementById("reset_edits_button");

    // check a change has actually been made before activating the submit and reset buttons
    CheckIfPageChanged ();
    return;
   }  // if globals.dragging

  // MOUSE CURSOR CHANGES

  // if not globals.dragging, change the mouse to indicate what we *can* do if we click
  SetMouseCursor (event);

} // end of onMouseMove

// test if the mouse is inside one of the globals.dragging boxes
function mouseInBox (mousex, mousey, x, y, hsize, vsize)
  {
  if (globals.mousex < (x * globals.width_multiple) - hsize / 2)
    return false;  // too far left
  if (globals.mousex > (x * globals.width_multiple) + hsize / 2)
    return false;  // too far right
  if (globals.mousey < (y * globals.height_multiple) - vsize / 2)
    return false;  // too far up
  if (globals.mousey > (y * globals.height_multiple) + vsize / 2)
    return false;  // too far down
  return true;
  } // end of mouseInBox

// mouse down event - set up for globals.dragging somewhere
function onMouseDown(event)
{
  globals.found   = false;
  globals.mousex  = event.offsetX;
  globals.mousey  = event.offsetY;

  // mouse down isn't active until we can see the handler boxes
  if (!globals.edit_clicked)
    return;

  // find active element
  for (var i = 0; i < num_elements; i++)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);
    // top left?
    if (mouseInBox (globals.mousex, globals.mousey, globals.startX, globals.startY, BOX_SIZE, BOX_SIZE))
      {
      globals.activeCorner = 'topleft';
      globals.found = true;
      break;
      }
    // top right?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.endX, globals.startY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
      {
      globals.activeCorner = 'topright';
      globals.found = true;
      break;
      }
    // bottom left?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.startX, globals.endY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
      {
      globals.activeCorner = 'bottomleft';
      globals.found = true;
      break;
      }
    // bottom right?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.endX, globals.endY, BOX_SIZE, BOX_SIZE))
      {
      globals.activeCorner = 'bottomright';
      globals.found = true;
      break;
      }
    // and now check the globals.dragging box
    else if (mouseInBox (globals.mousex, globals.mousey, globals.startX + (globals.endX - globals.startX) / 2, globals.startY, DRAGGING_BOX_SIZE, BOX_SIZE))
      {
      globals.activeCorner = 'drag';
      // remember where we clicked so we can get a delta location
      globals.dragMouseX = globals.mousex;
      globals.dragMouseY = globals.mousey;
      // remember where it was when we clicked
      globals.dragStartX = elements [globals.activeElement] [STARTX];
      globals.dragStartY = elements [globals.activeElement] [STARTY];
      globals.dragEndX   = elements [globals.activeElement] [ENDX];
      globals.dragEndY   = elements [globals.activeElement] [ENDY];
      globals.found = true;
      break;
      }

    } // end of for each element

  if (!globals.found)
    return;

  if (globals.activeCorner == 'drag')
    globals.canvas.style.cursor = 'move';
  else
    globals.canvas.style.cursor = 'nwse-resize';

  globals.dragging = true;

  document.getElementById('editing_notes').innerHTML = 'SHIFT to snap to grid, CTRL to reset position.';

} // end of onMouseDown

// mouse up handler - cancel ability to drag
function onMouseUp(event)
  {

  // ctrl key means discard moves and reset to defaults
  if (globals.dragging && event.ctrlKey && globals.activeCorner)
    {
    ResetOneElement (globals.activeElement);  // put the current element back to its default position
    CheckIfPageChanged ();
    drawborders ();     // redraw page
    }

  globals.activeCorner  = '';
  globals.dragging      = false;
  document.getElementById('editing_notes').innerHTML = '';
  SetMouseCursor (event);
  } // end of onMouseUp

// double-click in an element box edits that element (eg. to change the text)
function onDoubleClick(event)
  {
  var mousex = event.offsetX;
  var mousey = event.offsetY;

  if (globals.edits_done)
    {
    alert ("You have un-saved position edits - submit them or reset them.");
    return;
    }

  // check the globals.dragging boxes first in case a small element is inside a larger one
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    // let them double-click in the title box in case it is hard to find the element (eg. a line)
    if (mouseInBox (mousex, mousey, globals.startX + (globals.endX - globals.startX) / 2, globals.startY, DRAGGING_BOX_SIZE, BOX_SIZE))
      {
      button_to_click = document.getElementById("link_to_edit_element_".concat (globals.element_id));
      if (!button_to_click)
        return;   // can't find button
      button_to_click.click();    // activate it
      return;
      }
    } // end of for each element

  // now check the entire element rectangle
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    if (mousex < (globals.startX * globals.width_multiple))
      continue;  // too far left
    if (mousex > (globals.endX * globals.width_multiple))
      continue;  // too far right
    if (mousey < (globals.startY * globals.height_multiple))
      continue;  // too far up
    if (mousey > (globals.endY * globals.height_multiple))
      continue;  // too far down

    // globals.found the element!
    button_to_click = document.getElementById("link_to_edit_element_".concat (globals.element_id));
    if (!button_to_click)
      return;   // can't find button

    button_to_click.click();    // activate it
    return;
    } // end of for each element

  } // end of onDoubleClick

// START HERE

init ();  // get our globals.canvas and context

if (globals.canvas)
  {
  // mouse handlers
  globals.canvas.onmousedown = onMouseDown;
  globals.canvas.onmouseup   = onMouseUp;
  globals.canvas.ondblclick  = onDoubleClick;
  globals.canvas.onmousemove = onMouseMove;
  }


