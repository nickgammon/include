/*

Support functions, in Javascript, for the DTP system (see /hhs/dtp.php)


Copyright Â© 2019 Nick Gammon.

  Author: Nick Gammon <nick@gammon.com.au>
  Web:    http://www.gammon.com.au/
  Date:   November 2019

 PERMISSION TO DISTRIBUTE

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 and associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 LIMITATION OF LIABILITY

 The software is provided "as is", without warranty of any kind, express or implied,
 including but not limited to the warranties of merchantability, fitness for a particular
 purpose and noninfringement. In no event shall the authors or copyright holders be liable
 for any claim, damages or other liability, whether in an action of contract,
 tort or otherwise, arising from, out of or in connection with the software
 or the use or other dealings in the software.

  Note: The PHP file communicates with this module by passing down variables giving the element ID,
  element type and position of each element. The page width and page height are for converting from
  mm as used in the document and pixels as used on the screen.

  Example:

  var num_elements = 6;
  var page_width = 210;
  var page_height = 297;
  var grid_size_x = 8;
  var grid_size_y = 8;
  var elements = [
  [ 1, 1, 12, 23.04, 81, 76, 1, 0, 4, "cyan", "" ],
  [ 3, 3, 9, 227, 201, 227, 1, 0, 0.5, "black", "pink" ],
  [ 7, 5, 8, 8.08, 200, 17.04, 1, 0, 0, "", "" ],
  [ 11, 6, 74, 196, 145, 285, 0.83058823529412, 5, 1, "cyan", "#fff6d5" ],
  [ 3136, 1, 119, 189.04, 199, 279.04, 1, 0, 0, "", "red" ],
  [ 3137, 1, 158, 175.24, 200, 221.28, 1, 0, 0, "", "green" ],
  [ 3138, 1, 60, 3, 205, 151, 1, 0, 3, "red", "" ],
  ];

  Element array info as per "array position meanings" below. ie.

   [ ELEMENT_ID, ELEMENT_TYPE, STARTX, ENDX, ENDY, ASPECT_RATIO, CAPTION_HEIGHT,
     STROKE_WIDTH, "STROKE_COLOUR", "FILL_COLOUR" ],

*/

"use strict"

const BOX_SIZE = 10;   // size of corner boxes
const DRAGGING_BOX_SIZE = 30;  // width of globals.dragging box (height is BOX_SIZE)
const BOX_OPACITY = 1;
const BACKGROUND_OPACITY = 0.15;
const BACKGROUND_COLOUR = 'black';
const GAP_BETWEEN_IMAGE_AND_CAPTION = 1.5;  // (mm) see dtp.php - these should be the same
                                // I'm too lazy to automatically pass this figure down. :P

// array position meanings (as generated by dtp.php)
const ELEMENT_ID     = 0;
const ELEMENT_TYPE   = 1;
const STARTX         = 2;
const STARTY         = 3;
const ENDX           = 4;
const ENDY           = 5;
const ASPECT_RATIO   = 6;
const CAPTION_HEIGHT = 7;
const STROKE_WIDTH   = 8;
const STROKE_COLOUR  = 9;
const FILL_COLOUR    = 10;
const BORDER         = 11;

const LAST_ITEM = ENDY;  // must be last element in array (above) which changes dynamically

// element types
const ELEMENT_RECTANGLE         = 1;
const ELEMENT_ELLIPSE           = 2;
const ELEMENT_LINE              = 3;
const ELEMENT_STAR              = 4;
const ELEMENT_TEXT              = 5;
const ELEMENT_IMAGE             = 6;
const ELEMENT_TEXT_CONTINUATION = 7;

// for the page grid
const GRID_SIZE_X = 8;    // also should be the same as in dtp.php
const GRID_SIZE_Y = 8;    // is there no end to my laziness? ;)

// put our global variables here to make it clear they are global
var globals = [];

// Initialization: called on load of script
function init()
  {
  console.log ("Javascript dtp.js initialising")

  globals.canvas = document.getElementById("mycanvas");  // our globals.canvas

  if (globals.canvas)
    {
    globals.ctx = globals.canvas.getContext("2d");                 // our drawing context
    // convert width from mm into pixels as displayed on the page
    globals.width_multiple  = globals.canvas.width / page_width;
    globals.height_multiple = globals.canvas.height / page_height;

    // make a copy of element positions so we can reset to the beginning state
    globals.orig_elements = [];
    for (var i = 0; i < num_elements; i++)
      {
      globals.orig_elements [i] = [];
      for (var j = 0; j <= LAST_ITEM; j++)
        globals.orig_elements [i] [j] = elements [i] [j];
      }
    // get ready for dropping images

    globals.canvas.addEventListener('dragenter', canvasDragEnter)
    globals.canvas.addEventListener('dragover',  canvasDragOver);
    globals.canvas.addEventListener('dragleave', canvasDragLeave);
    globals.canvas.addEventListener('drop',      canvasDropImage);
    console.log ("Created canvas")
    } // end of if globals.canvas exists

  // they haven't clicked the "Edit" button yet
  globals.edit_clicked = false;
  globals.edits_done   = false;
  globals.dragging     = false;

  // stop default drag and drop behaviour, so missing the page doesn't open a new
  // page with the image on it

  // as for the semicolon, see this: https://stackoverflow.com/questions/58069078/semicolon-before-square-bracket

  var body_div =  document.getElementById('main_page_body')
  if (body_div)
    {
    ;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      body_div.addEventListener(eventName, preventDefaults, false)
    })
    } // if we found main_page_body div

  // nor the "add new element" button
  globals.adding       = false;
  globals.started_dragging = false;

  globals.submit_edits_button = document.getElementById("submit_edits_button");
  globals.submit_edits_button.onclick = SubmitEditsClicked;
  
  globals.reset_edits_button = document.getElementById("reset_edits_button");

  // for adding elements by clicking and dragging
  globals.add_text_button = document.getElementById("add_text_button");
  globals.add_text_button.onclick = AddTextClicked;

  globals.add_heading_button = document.getElementById("add_heading_button");
  globals.add_heading_button.onclick = AddHeadingClicked;

  globals.add_continuation_button = document.getElementById("add_continuation_button");
  globals.add_continuation_button.onclick = AddContinuationClicked;

  globals.add_box_button = document.getElementById("add_box_button");
  globals.add_box_button.onclick = AddBoxClicked;

  globals.add_vline_button = document.getElementById("add_vline_button");
  globals.add_vline_button.onclick = AddVlineClicked;

  globals.add_hline_button = document.getElementById("add_hline_button");
  globals.add_hline_button.onclick = AddHlineClicked;

  globals.add_image_button = document.getElementById("add_image_button");
  globals.add_image_button.onclick = AddImageClicked;

  globals.add_ellipse_button = document.getElementById("add_ellipse_button");
  globals.add_ellipse_button.onclick = AddEllipseClicked;

  globals.add_star_button = document.getElementById("add_star_button");
  globals.add_star_button.onclick = AddStarClicked;

  // see if our main image has loaded, if not set up a handler for it
  var image = document.getElementById('full-page-image')
  var isLoaded = image.complete && image.naturalHeight !== 0;

  var markdown_convert_drop_zone = document.getElementById ('markdown_convert_drop_zone')
  if (markdown_convert_drop_zone)
    {
    markdown_convert_drop_zone.addEventListener('dragenter', markdownConvertEnter)
    markdown_convert_drop_zone.addEventListener('dragover',  markdownConvertOver);
    markdown_convert_drop_zone.addEventListener('dragleave', markdownConvertLeave);
    markdown_convert_drop_zone.addEventListener('drop',      markdownConvertDrop);
    }

  if (isLoaded)
    draw_main_image ()
  else
    image.onload = draw_main_image

  if (globals.canvas)
    {
    // mouse handlers
    globals.canvas.onmousedown = onMouseDown;
    globals.canvas.onmouseup   = onMouseUp;
    globals.canvas.ondblclick  = onDoubleClick;
    globals.canvas.onmousemove = onMouseMove;
    }

  } // end of init

function preventDefaults (e) {
  e.preventDefault()
  e.stopPropagation()
}

// draw one of the four corner boxes
function drawCornerBox (x, y)
  {
  globals.ctx.beginPath();
  globals.ctx.rect((x * globals.width_multiple)   - BOX_SIZE / 2,
           (y * globals.height_multiple)  - BOX_SIZE / 2,
           BOX_SIZE,
           BOX_SIZE
           );
  globals.ctx.fillStyle = "green";
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.fill ();
  } // end of drawCornerBox

// fill with different colours to make the different elements stand out from each other
var movedFillColours = [
  'Red',
  'Green',
  'Blue',
  'Cyan',
  'Magenta',
  'Yellow',
  'Black',
];

// extract out one array element into global variables
function getElementDetails (element)
  {
  // extract out fields from database
  globals.element_id    = element [ELEMENT_ID];
  globals.element_type  = element [ELEMENT_TYPE];
  globals.startX        = element [STARTX];
  globals.startY        = element [STARTY];
  globals.endX          = element [ENDX];
  globals.endY          = element [ENDY];
  globals.aspect_ratio  = element [ASPECT_RATIO];
  globals.caption_height= element [CAPTION_HEIGHT];
  globals.stroke_width  = element [STROKE_WIDTH];
  globals.stroke_colour = element [STROKE_COLOUR];
  globals.fill_colour   = element [FILL_COLOUR];
  globals.border        = element [BORDER];

  } // end of getElementDetails

// draw element borders, plus resizing and moving handles
function drawborders ()
{
var mainImage = document.getElementById("full-page-image")

globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas

globals.ctx.globalAlpha = 0.4;
draw_main_image ()
globals.ctx.globalAlpha = 1;

// first draw all the images

for (var i = 0; i < num_elements; i++)
  {
  // get *this* element
  getElementDetails (elements [i]);

  var origX, origY, origwX, origwY, dX, dY, dwX, dwY;

  // original (source) of the image
  origX = globals.orig_elements [i] [STARTX]  * globals.width_multiple
  origY = globals.orig_elements [i] [STARTY]  * globals.height_multiple
  origwX = (globals.orig_elements [i] [ENDX]  - globals.orig_elements [i] [STARTX])  * globals.width_multiple
  origwY = (globals.orig_elements [i] [ENDY] - globals.orig_elements [i] [STARTY])  * globals.height_multiple

  // current (destination) image
  dX = globals.startX * globals.width_multiple
  dY = globals.startY * globals.height_multiple
  dwX = (globals.endX - globals.startX) * globals.width_multiple
  dwY = (globals.endY - globals.startY) * globals.height_multiple

  // fill the entire element
  globals.ctx.beginPath();

  globals.ctx.rect(dX, dY, dwX, dwY);

  // fill box if moved from original position
  if (ElementChanged (i))
    {
    globals.ctx.fillStyle = 'white';
//    globals.ctx.fillStyle = movedFillColours [i % movedFillColours.length];
    globals.ctx.globalAlpha = BACKGROUND_OPACITY;  // low opacity fill
    globals.ctx.globalAlpha = BACKGROUND_OPACITY * (Math.floor (i / movedFillColours.length) + 1);
    globals.ctx.fill();
    }

  // draw its image
  globals.ctx.globalAlpha = 1;
  globals.ctx.save ()

  // rectangles, text and images can have fill or strokes
  if (globals.element_type == ELEMENT_RECTANGLE ||
      globals.element_type == ELEMENT_TEXT ||
      globals.element_type == ELEMENT_TEXT_CONTINUATION ||
      globals.element_type == ELEMENT_IMAGE)
    {
    globals.ctx.beginPath()
    globals.ctx.rect(dX, dY, dwX, dwY)

    if (globals.fill_colour)
      {
      globals.ctx.fillStyle = globals.fill_colour;
      globals.ctx.fill();
      } // end of having a fill

    if (globals.stroke_width > 0 && globals.stroke_colour)
      {
      globals.ctx.strokeStyle = globals.stroke_colour
      globals.ctx.lineWidth = globals.stroke_width
      globals.ctx.stroke();
      } // end of having a stroke
    }

  globals.ctx.restore ()

  globals.ctx.save ()

  // stretch images to fit but not other things
  if (globals.element_type == ELEMENT_IMAGE)
    {
    var thisImage = document.getElementById("source_image_" + globals.element_id)
    var dwXadj = Math.min (dwY * globals.aspect_ratio, dwX)
    var dwYadj = Math.min (dwX / globals.aspect_ratio, dwY)

    globals.ctx.drawImage (thisImage, dX + (dwX - dwXadj) / 2, dY  + (dwY - dwYadj) / 2, dwXadj, dwYadj)
    console.log ("Drawing image " + " source_image_" + globals.element_id)
    } // end of ELEMENT_IMAGE
  else if ((globals.element_type == ELEMENT_TEXT || globals.element_type == ELEMENT_TEXT_CONTINUATION)
          && ElementChanged (i))
    {
    globals.ctx.strokeStyle = 'lightgray'
    globals.ctx.lineWidth = 10
    // draw some thick lines to indicate text
    for (var y = dY + 10; y < (dY + dwY); y += 20)
      {
      globals.ctx.beginPath()
      globals.ctx.moveTo (dX, y)
      globals.ctx.lineTo (dX + dwX, y)
      globals.ctx.stroke();
      } // end of for each thick line

    }   // end of ELEMENT_TEXT or ELEMENT_TEXT_CONTINUATION
  else if (globals.element_type == ELEMENT_RECTANGLE)
    {
    // do nothing, we already drew it
    } // end of ELEMENT_RECTANGLE
  else if (globals.element_type == ELEMENT_LINE)
    {
    if (globals.stroke_width > 0 && globals.stroke_colour)
      {
      globals.ctx.beginPath()
      globals.ctx.strokeStyle = globals.stroke_colour
      globals.ctx.lineWidth = globals.stroke_width
      globals.ctx.moveTo (dX, dY)
      globals.ctx.lineTo (dX + dwX, dY + dwY)
      globals.ctx.stroke();
      } // end of having a stroke

    } // end of ELEMENT_LINE
  else if (globals.element_type == ELEMENT_ELLIPSE)
    {
    globals.ctx.beginPath()
    globals.ctx.ellipse(dX + (dwX / 2), dY + (dwY / 2), dwX / 2, dwY / 2, 0, 0, Math.PI * 2)

    if (globals.fill_colour)
      {
      globals.ctx.fillStyle = globals.fill_colour;
      globals.ctx.fill();
      } // end of having a fill

    if (globals.stroke_width > 0 && globals.stroke_colour)
      {
      globals.ctx.strokeStyle = globals.stroke_colour
      globals.ctx.lineWidth = globals.stroke_width
      globals.ctx.stroke();
      } // end of having a stroke

    } // end of ELEMENT_ELLIPSE
  else
    globals.ctx.drawImage (mainImage, origX, origY, origwX, origwY, dX, dY, origwX, origwY)

  globals.ctx.restore ()

  }

// now the borders

for (var i = 0; i < num_elements; i++)
  {
  // get *this* element
  getElementDetails (elements [i]);

  var dX, dY, dwX, dwY, borderX, borderY, captionHeight;

  dX = globals.startX * globals.width_multiple
  dY = globals.startY * globals.height_multiple
  dwX = (globals.endX - globals.startX) * globals.width_multiple
  dwY = (globals.endY - globals.startY) * globals.height_multiple
  borderX = globals.border * globals.width_multiple
  borderY = globals.border * globals.height_multiple
  captionHeight = (globals.caption_height) * globals.height_multiple
  // there is a gap between the image and the caption
  if (captionHeight)
    captionHeight += GAP_BETWEEN_IMAGE_AND_CAPTION  * globals.height_multiple

  // stroke the entire element (box around it)
  globals.ctx.beginPath();

  globals.ctx.rect(dX, dY, dwX, dwY + captionHeight);


  // draw box around it
  globals.ctx.strokeStyle = "green";
  globals.ctx.setLineDash([]);
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.stroke();

  // draw a dashed line to indicate the border area
  if (globals.border)
    {
    globals.ctx.rect(dX - borderX, dY - borderY, dwX  + (borderX * 2), dwY + (borderY * 2) + captionHeight);

    // draw box around it
    globals.ctx.strokeStyle = "green";
    globals.ctx.setLineDash([5, 5]);
    globals.ctx.globalAlpha = BOX_OPACITY;
    globals.ctx.stroke();
    }

  // corner boxes (small boxes at corners) TOP LEFT
  drawCornerBox (globals.startX, globals.startY);

  // lines only have two corners
  if (globals.element_type != ELEMENT_LINE)
    {
    drawCornerBox (globals.endX, globals.startY);  // TOP RIGHT
    drawCornerBox (globals.startX, globals.endY);  // BOTTOM LEFT
    }

  // corner box BOTTOM RIGHT
  drawCornerBox (globals.endX, globals.endY);

/*
  // draw globals.dragging box
  globals.ctx.beginPath();
  var x = globals.startX + ((globals.endX - globals.startX) / 2);  // half way along
  globals.ctx.rect((x * globals.width_multiple) - (DRAGGING_BOX_SIZE / 2),
           (globals.startY * globals.height_multiple)  - BOX_SIZE / 2,
           DRAGGING_BOX_SIZE,
           BOX_SIZE
           );
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.fillStyle = "green";
  globals.ctx.fill ();
*/

  } // end of for each element

  // now the grid

  globals.ctx.globalAlpha = 0.5;
  globals.ctx.strokeStyle = 'gray'

  // vertical grid (each X position - vertical lines)
  for (var x = GRID_SIZE_X  * globals.width_multiple; x < globals.canvas.width; x += GRID_SIZE_X * globals.width_multiple)
    {
     globals.ctx.beginPath();
     globals.ctx.moveTo(x, GRID_SIZE_Y * globals.height_multiple);
     // don't overshoot last horizontal grid
     var y2 = globals.canvas.height - ((GRID_SIZE_Y  - 1 ) * globals.height_multiple)
     y2 = Math.floor (y2 / (GRID_SIZE_Y  * globals.height_multiple)) *  (GRID_SIZE_Y  * globals.height_multiple)
     globals.ctx.lineTo(x, y2)
     globals.ctx.stroke();
    }

  // horizontal grid (each y position - horizontal lines)
  for (var y = GRID_SIZE_Y * globals.height_multiple; y < globals.canvas.height; y += GRID_SIZE_Y * globals.height_multiple)
    {
     globals.ctx.beginPath();
     globals.ctx.moveTo(GRID_SIZE_X * globals.width_multiple , y);
     // don't overshoot last vertical grid
     var x2 = globals.canvas.width - ((GRID_SIZE_X  - 1 ) * globals.width_multiple)
     x2 = Math.floor (x2 / (GRID_SIZE_X  * globals.width_multiple)) *  (GRID_SIZE_X  * globals.width_multiple)
     globals.ctx.lineTo(x2, y)
     globals.ctx.stroke();
    }

  globals.ctx.globalAlpha = 1;

} // end of drawborders

// helper function to reset one element back to its original position
function ResetOneElement (which)
  {

  // copy values back
  for (var j = 0; j <= LAST_ITEM; j++)
    elements [which] [j] = globals.orig_elements [which] [j];

  // put the HTML values back
  globals.element_id = elements [which] [ELEMENT_ID];

  // fix up globals.startX
  globals.startXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startX"));
  globals.startXonPage [0].value = elements [which] [STARTX];

  // fix up globals.startY
  globals.startYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startY"));
  globals.startYonPage [0].value = elements [which] [STARTY];

  // fix up globals.endX
  globals.endXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endX"));
  globals.endXonPage [0].value = elements [which] [ENDX];

  // fix up globals.endY
  globals.endYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endY"));
  globals.endYonPage [0].value = elements [which] [ENDY];

  } // end of ResetOneElement

// here when the "Reset" button clicked - put everything back to how it was
function ResetClicked (event)
{
  console.log ("Reset edits clicked")
  globals.submit_edits_button.disabled = true;

  globals.reset_edits_button.disabled = true;

  // reset all elements
  for (var i = 0; i < num_elements; i++)
    ResetOneElement (i);

  drawborders ();   // redraw original positions
  globals.edits_done = false;
  return false;     // don't submit form
} // end of ResetClicked

// here when the "Edit" / "Submit edits" button is clicked
function SubmitEditsClicked (event)
{
  // don't edit and add stuff at the same time
  if (globals.adding)
    return false;

  if (!globals.edit_clicked)
    {
    console.log ("Edit button clicked")
    globals.edit_clicked          = true;
    globals.submit_edits_button.value     = "Submit edits";
    globals.submit_edits_button.disabled  = true;  // nothing edited yet
    drawborders ();
    event.preventDefault();
    document.getElementById("ctrl_click_message").style.display = 'none'
    return false;   // don't submit yet
    }
  console.log ("Submitting edits")
  return true;  // submit form now
} // end of SubmitEditsClicked

function AddElementClicked (adding_type, button)
{
  // don't edit and add stuff at the same time
  if (globals.edit_clicked)
    return false;

  if (!globals.adding)
    {
    globals.adding            = true
    globals.started_dragging  = false
    globals.adding_type     = adding_type
    globals.canvas.style.cursor = 'crosshair';
    globals.add_element_button = button
    globals.add_element_button.disabled  = true;  // can't click it again

    // save type of add
    var add_element_type = document.getElementsByName("add_element_type");
    add_element_type [0].value = globals.adding_type

    document.getElementById('editing_notes').innerHTML = 'SHIFT to snap to grid, CTRL to cancel adding an element'
    }
} // end of AddElementClicked

// here when the "Add text block" button is clicked
function AddTextClicked (event)
  {
  AddElementClicked ('text', globals.add_text_button)
  return false;   // don't submit yet
  } // end of AddTextClicked

// here when the "Add heading block" button is clicked
function AddHeadingClicked (event)
  {
  AddElementClicked ('heading', globals.add_heading_button)
  return false;   // don't submit yet
  } // end of AddHeadingClicked

// here when the "Add text continuation block" button is clicked
function AddContinuationClicked (event)
  {
  AddElementClicked ('continuation', globals.add_continuation_button)
  return false;   // don't submit yet
  } // end of AddContinuationClicked

// here when the "Add box" button is clicked
function AddBoxClicked (event)
  {
  AddElementClicked ('box', globals.add_box_button)
  return false;   // don't submit yet
  } // end of AddBoxClicked

// here when the "Add vertical line" button is clicked
function AddVlineClicked (event)
  {
  AddElementClicked ('vertical line', globals.add_vline_button)
  return false;   // don't submit yet
  } // end of AddVlineClicked

// here when the "Add horizontal line" button is clicked
function AddHlineClicked (event)
  {
  AddElementClicked ('horizontal line', globals.add_hline_button)
  return false;   // don't submit yet
  } // end of AddHlineClicked

// here when the "Add image" button is clicked
function AddImageClicked (event)
  {
  AddElementClicked ('image', globals.add_image_button)
  return false;   // don't submit yet
  } // end of AddImageClicked

// here when the "Add ellipse line" button is clicked
function AddEllipseClicked (event)
  {
  AddElementClicked ('ellipse', globals.add_ellipse_button)
  return false;   // don't submit yet
  } // end of AddEllipseClicked

// here when the "Add star" button is clicked
function AddStarClicked (event)
  {
  AddElementClicked ('star', globals.add_star_button)
  return false;   // don't submit yet
  } // end of AddStarClicked

// returns true if this element has globals.changed from its original position
function ElementChanged (which)
  {
  return elements [which] [STARTX] != globals.orig_elements [which] [STARTX] ||
         elements [which] [ENDX]   != globals.orig_elements [which] [ENDX] ||
         elements [which] [STARTY] != globals.orig_elements [which] [STARTY] ||
         elements [which] [ENDY]   != globals.orig_elements [which] [ENDY];
  } // end of ElementChanged

// see if the page has globals.changed by checking all elements
function CheckIfPageChanged ()
  {
  globals.changed = false;  // no changes yet

  // check each element
  for (var i = 0; i < num_elements; i++)
    if (ElementChanged (i))
      globals.changed = true;

  if (globals.changed)
    {
    globals.submit_edits_button.disabled  = false;
    globals.reset_edits_button.disabled   = false;
    globals.reset_edits_button.onclick    = ResetClicked;
    globals.edits_done            = true;
    }
  else
    {
    // no changes? make sure submit and reset buttons are disabled
    // - this is for the situation where you make a change and then change it back
    globals.submit_edits_button.disabled  = true;
    globals.reset_edits_button.disabled   = true;
    globals.reset_edits_button.onclick    = null;
    globals.edits_done            = false;
    }
  } // end of CheckIfPageChanged

// set the appropriate mouse cursor shape depending on what it is hovering over, if anything
function SetMouseCursor (event)
  {
  var mousex = event.offsetX;
  var mousey = event.offsetY;

  // find active element, assuming we can see them (edit button has been clicked)
  if (globals.edit_clicked)
    {
    // go backwards so that the higher (on top) one gets selected before the one underneath
    for (var i = num_elements - 1; i >= 0; i--)
      {
      globals.activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);
      // top left?
      if (mouseInBox (mousex, mousey, globals.startX, globals.startY, BOX_SIZE, BOX_SIZE))
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // top right?
      else if (mouseInBox (mousex, mousey, globals.endX, globals.startY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // bottom left?
      else if (mouseInBox (mousex, mousey, globals.startX, globals.endY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // bottom right?
      else if (mouseInBox (mousex, mousey, globals.endX, globals.endY, BOX_SIZE, BOX_SIZE))
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      } // end of for each element

    // and now check the dragging area last because the selection boxes take precedence
    // go backwards so that the higher (on top) one gets selected before the one underneath
    for (var i = num_elements - 1; i >= 0; i--)
      {
      globals.activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);
      if (mouseInElement (mousex, mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
        {
        globals.canvas.style.cursor = 'move';
        return;
        }
      } // end of for each element

    }   // of edit button active

  // edit button or not, we can double-click elements

  // check the entire element rectangle
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    if (mouseInElement (mousex, mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
      {
      // found the element!
      globals.canvas.style.cursor = 'pointer';
      return;
      }
    } // end of for each element

  // mouse isn't anywhere interesting
  globals.canvas.style.cursor = 'default';

  } // end of SetMouseCursor

// mouse move handler - resize the element box (or move it) assuming we had a previous mouse down
function onMouseMove(event)
{
  globals.mousex = event.offsetX;
  globals.mousey = event.offsetY;

  if (globals.adding)
    {
    globals.canvas.style.cursor = 'crosshair';

    if (globals.started_dragging)
      {
      var mainImage = document.getElementById("full-page-image")
      globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas

      globals.ctx.globalAlpha = 0.8;
      draw_main_image ()
      globals.ctx.globalAlpha = 1;

      // find new position in mm
      var x = Math.round(globals.mousex / globals.width_multiple);
      var y = Math.round(globals.mousey / globals.height_multiple);

      // shift key snaps to the grid
      if (event.shiftKey)
        {
        x = Math.round(x / grid_size_x) * grid_size_x;
        y = Math.round(y / grid_size_y) * grid_size_y;
        }

      // convert back to pixels
      x *= globals.width_multiple
      y *= globals.height_multiple

      // draw its outline
      globals.ctx.globalAlpha = 1;
      globals.ctx.save ()
      globals.ctx.beginPath()
      globals.ctx.rect(globals.box_startx, globals.box_starty,
                      x - globals.box_startx,
                      y - globals.box_starty)
      globals.ctx.strokeStyle = "green"
      globals.ctx.lineWidth = 3
      globals.ctx.stroke();
      globals.ctx.fillStyle = "green";
      globals.ctx.globalAlpha = 0.2;
      globals.ctx.fill ();
      globals.ctx.restore ()


      // fix up startX
      var add_element_startX = document.getElementsByName("add_element_startX");
      add_element_startX [0].value = globals.box_startx / globals.width_multiple;

      // fix up startY
      var add_element_startY = document.getElementsByName("add_element_startY");
      add_element_startY [0].value = globals.box_starty / globals.height_multiple;

      // fix up endX
      var add_element_endX = document.getElementsByName("add_element_endX");
      add_element_endX [0].value = x / globals.width_multiple;

       // fix up endY
      var add_element_endY = document.getElementsByName("add_element_endY");
      add_element_endY [0].value = y / globals.height_multiple;

      } // end of currently dragging

    return;
    }

  // if not globals.dragging, change the mouse to indicate what we *can* do if we click
  if (!globals.dragging)
  {
  SetMouseCursor (event);
  return
  }

  // if globals.dragging (mouse down previously) update the element's position depending on where we move to

  // find new position in mm
  var x = Math.round(globals.mousex / globals.width_multiple);
  var y = Math.round(globals.mousey / globals.height_multiple);

  // shift key snaps to the grid
  if (event.shiftKey)
    {
    x = Math.round(x / grid_size_x) * grid_size_x;
    y = Math.round(y / grid_size_y) * grid_size_y;
    }

  globals.element_type = elements [globals.activeElement] [ELEMENT_TYPE];

  // update element - depending on which corner was being moved

  // top left
  if (globals.activeCorner == 'topleft' && globals.element_type == ELEMENT_LINE)
    {
    // lines can line up vertically and horizontally
    if (x <= elements [globals.activeElement] [ENDX] && y <= elements [globals.activeElement] [ENDY])
      {
      elements [globals.activeElement] [STARTX] = x;
      elements [globals.activeElement] [STARTY] = y;
      }
    }
  else if (globals.activeCorner == 'topleft' && globals.element_type != ELEMENT_LINE)
    {
    if (x < elements [globals.activeElement] [ENDX] && y < elements [globals.activeElement] [ENDY])
      {
      elements [globals.activeElement] [STARTX] = x;
      elements [globals.activeElement] [STARTY] = y;
      }
    }

  // top right
  else if (globals.activeCorner == 'topright')
    {
    if (x > elements [globals.activeElement] [STARTX] && y < elements [globals.activeElement] [ENDY])
      {
      elements [globals.activeElement] [ENDX] = x;
      elements [globals.activeElement] [STARTY] = y;
      }
    }

  // bottom left
  else if (globals.activeCorner == 'bottomleft')
    {
    if (x < elements [globals.activeElement] [ENDX] && y > elements [globals.activeElement] [STARTY])
      {
      elements [globals.activeElement] [STARTX] = x;
      elements [globals.activeElement] [ENDY] = y;
      }
    }

 // bottom right
 else if (globals.activeCorner == 'bottomright' && globals.element_type == ELEMENT_LINE)
    {
    // lines can line up vertically and horizontally
    if (x >= elements [globals.activeElement] [STARTX] && y >= elements [globals.activeElement] [STARTY])
      {
      elements [globals.activeElement] [ENDX] = x;
      elements [globals.activeElement] [ENDY] = y;
      }
    }
 else if (globals.activeCorner == 'bottomright' && globals.element_type != ELEMENT_LINE)
    {
    if (x > elements [globals.activeElement] [STARTX] && y > elements [globals.activeElement] [STARTY])
      {
      elements [globals.activeElement] [ENDX] = x;
      elements [globals.activeElement] [ENDY] = y;
      }
    }

  // drag box (reposition)
  else if (globals.activeCorner == 'drag')
    {
    var deltaX = Math.round((globals.dragMouseX - event.offsetX) / globals.width_multiple);
    var deltaY = Math.round((globals.dragMouseY - event.offsetY) / globals.height_multiple);

    var new_x = globals.dragStartX - deltaX;
    var new_y = globals.dragStartY - deltaY;
    var width = elements [globals.activeElement]  [ENDX] - elements [globals.activeElement] [STARTX];
    var height = elements [globals.activeElement] [ENDY] - elements [globals.activeElement] [STARTY];

    // shift key snaps to the grid
    if (event.shiftKey)
      {
      new_x = Math.round(new_x / grid_size_x) * grid_size_x;
      new_y = Math.round(new_y / grid_size_y) * grid_size_y;
      }

    elements [globals.activeElement] [STARTX] = new_x;
    elements [globals.activeElement] [STARTY] = new_y;
    elements [globals.activeElement] [ENDX]   = new_x + width;
    elements [globals.activeElement] [ENDY]   = new_y + height;
    }

  drawborders ();

  // update form ready for them to post it

  // turn element array number into an element ID
  globals.element_id = elements [globals.activeElement] [ELEMENT_ID];

  // fix up globals.startX
  globals.startXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startX"));
  globals.startXonPage [0].value = elements [globals.activeElement] [STARTX];

  // fix up globals.startY
  globals.startYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startY"));
  globals.startYonPage [0].value = elements [globals.activeElement] [STARTY];

  // fix up globals.endX
  globals.endXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endX"));
  globals.endXonPage [0].value = elements [globals.activeElement] [ENDX];

  // fix up globals.endY
  globals.endYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endY"));
  globals.endYonPage [0].value = elements [globals.activeElement] [ENDY];

  // check a change has actually been made before activating the submit and reset buttons
  CheckIfPageChanged ();


} // end of onMouseMove

// test if the mouse is inside one of the globals.dragging boxes
function mouseInBox (mousex, mousey, x, y, hsize, vsize)
  {
  if (mousex < (x * globals.width_multiple) - hsize / 2)
    return false;  // too far left
  if (mousex > (x * globals.width_multiple) + hsize / 2)
    return false;  // too far right
  if (mousey < (y * globals.height_multiple) - vsize / 2)
    return false;  // too far up
  if (mousey > (y * globals.height_multiple) + vsize / 2)
    return false;  // too far down
  return true;
  } // end of mouseInBox

// test if the mouse is inside one of the elements
function mouseInElement (mousex, mousey, sx, sy, ex, ey)
  {
  // a line, being infinitely thin, will appear to always match
  // so, make it one pixel wide.

  if (Math.abs (sx - ex) < 2)
    ex++;
  if (Math.abs (sy - ey) < 2)
    ey++;

  if (mousex < (sx * globals.width_multiple))
    return false;  // too far left
  if (mousex > (ex * globals.width_multiple))
    return false;  // too far right
  if (mousey < (sy * globals.height_multiple))
    return false;  // too far up
  if (mousey > (ey * globals.height_multiple))
    return false;  // too far down
  return true;
  } // end of mouseInElement

// mouse down event - set up for globals.dragging somewhere
function onMouseDown(event)
{
  globals.found   = false;
  globals.mousex  = event.offsetX;
  globals.mousey  = event.offsetY;
  console.log ("onMouseDown")

  // Ctrl+Click to toggle selection in the list on the right
  if (!globals.adding && !globals.edit_clicked && event.ctrlKey)
    {
    // check the entire element rectangle
    // go backwards so that the higher (on top) one gets selected before the one underneath
    for (var i = num_elements - 1; i >= 0; i--)
      {
      globals.activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);

      if (mouseInElement (globals.mousex, globals.mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
        {
        // found the element!
        var selection_to_click = document.getElementById("checkbox_to_select_".concat (globals.element_id));
        if (!selection_to_click)
          return;   // can't find button

        selection_to_click.click();    // activate it
        return;
        }
      } // end of for each element

    return;
    }


  if (globals.started_dragging)
    return;

  // HERE for ADDING NEW ELEMENTS

  if (globals.adding)
    {
    globals.started_dragging = true;

    // find new position in mm
    var x = Math.round(globals.mousex / globals.width_multiple);
    var y = Math.round(globals.mousey / globals.height_multiple);

    // shift key snaps to the grid
    if (event.shiftKey)
      {
      x = Math.round(x / grid_size_x) * grid_size_x;
      y = Math.round(y / grid_size_y) * grid_size_y;
      }

    // convert back to pixels
    x *= globals.width_multiple
    y *= globals.height_multiple

    globals.box_startx = x
    globals.box_starty = y
    return
    } // end of adding an element


  // HERE for MOVING EXISTING ELEMENTS

  // mouse down isn't active until we can see the handler boxes
  if (!globals.edit_clicked)
    return;

  // find active element
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);
    // top left?
    if (mouseInBox (globals.mousex, globals.mousey, globals.startX, globals.startY, BOX_SIZE, BOX_SIZE))
      {
      globals.activeCorner = 'topleft';
      globals.found = true;
      break;
      }
    // top right?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.endX, globals.startY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
      {
      globals.activeCorner = 'topright';
      globals.found = true;
      break;
      }
    // bottom left?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.startX, globals.endY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
      {
      globals.activeCorner = 'bottomleft';
      globals.found = true;
      break;
      }
    // bottom right?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.endX, globals.endY, BOX_SIZE, BOX_SIZE))
      {
      globals.activeCorner = 'bottomright';
      globals.found = true;
      break;
      }
    } // end of for each element

  // now check the overall rectangle in case they didn't click on a resize box
  // this is so the resize boxes take precedence over the general drag area

  // go backwards so that the higher (on top) one gets selected before the one underneath
  if (!globals.found)
    {
    for (var i = num_elements - 1; i >= 0; i--)
      {
      globals.activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);

      if (mouseInElement (globals.mousex, globals.mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
          {
          globals.activeCorner = 'drag';
          // remember where we clicked so we can get a delta location
          globals.dragMouseX = globals.mousex;
          globals.dragMouseY = globals.mousey;
          // remember where it was when we clicked
          globals.dragStartX = elements [globals.activeElement] [STARTX];
          globals.dragStartY = elements [globals.activeElement] [STARTY];
          globals.dragEndX   = elements [globals.activeElement] [ENDX];
          globals.dragEndY   = elements [globals.activeElement] [ENDY];
          globals.found = true;
          break;
          }

      } // end of for each element
    } // if not found via a resize box

  if (!globals.found)
    return;

  if (globals.activeCorner == 'drag')
    globals.canvas.style.cursor = 'move';
  else
    globals.canvas.style.cursor = 'nwse-resize';

  globals.dragging = true;

  document.getElementById('editing_notes').innerHTML = 'SHIFT to snap to grid, CTRL to reset position.<br>'
     + 'Text (indicated by grey bars) does not dynamically reflow.<br>'
     + 'Not all styles are applied while editing (eg. opacity, dotted lines).'

} // end of onMouseDown

// mouse up handler - cancel ability to drag
function onMouseUp(event)
  {

  document.getElementById('editing_notes').innerHTML = '';

  if (globals.adding)
    {
    globals.adding = false

    // if Ctrl pressed, do nothing
    if (event.ctrlKey || !globals.started_dragging)
      {
      globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas
      globals.ctx.globalAlpha = 1;
      draw_main_image ()
      globals.add_element_button.disabled  = false
      return;
      }

    globals.started_dragging = false;
    document.getElementById("add_element_box").submit();
    return
    }


  // ctrl key means discard moves and reset to defaults
  if (globals.dragging && event.ctrlKey && globals.activeCorner)
    {
    ResetOneElement (globals.activeElement);  // put the current element back to its default position
    CheckIfPageChanged ();
    drawborders ();     // redraw page
    }

  globals.activeCorner  = '';
  globals.dragging      = false;
  SetMouseCursor (event);
  } // end of onMouseUp

// double-click in an element box edits that element (eg. to change the text)
function onDoubleClick(event)
  {
  var mousex = event.offsetX;
  var mousey = event.offsetY;

  if (globals.edits_done)
    {
    alert ("You have un-saved position edits - submit them or reset them.");
    return;
    }

  // check the globals.dragging boxes first in case a small element is inside a larger one
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    // let them double-click in the title box in case it is hard to find the element (eg. a line)
    if (mouseInBox (mousex, mousey, globals.startX + (globals.endX - globals.startX) / 2, globals.startY, DRAGGING_BOX_SIZE, BOX_SIZE))
      {
      var button_to_click = document.getElementById("link_to_edit_element_".concat (globals.element_id));
      if (!button_to_click)
        return;   // can't find button
      button_to_click.click();    // activate it
      return;
      }
    } // end of for each element

  // now check the entire element rectangle
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    if (mouseInElement (mousex, mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
      {
      var idName = 'link_to_edit_element_'
      if (event.altKey)
        idName = 'triangle_to_expand_'

      // found the element!
      var button_to_click = document.getElementById(idName.concat (globals.element_id));
      if (!button_to_click)
        return;   // can't find button

      button_to_click.click();    // activate it
      return;
      }
    } // end of for each element

  } // end of onDoubleClick

function draw_selection ()
{
  const LINE_BORDER = 6;
  globals.ctx.save ()

  globals.ctx.globalAlpha = 1;
  globals.ctx.lineWidth = 2;

  for (var i = 0; i < num_elements; i++)
    {
    // get *this* element
    getElementDetails (elements [i]);

    var dX, dY, dwX, dwY;

    dX = globals.startX * globals.width_multiple
    dY = globals.startY * globals.height_multiple
    dwX = (globals.endX - globals.startX) * globals.width_multiple
    dwY = (globals.endY - globals.startY) * globals.height_multiple

    var element_checkbox = document.getElementById("checkbox_to_select_".concat (globals.element_id));

    if (element_checkbox && element_checkbox.checked)
      {
      // stroke the entire element (box around it)
      globals.ctx.beginPath();

      // make lines bigger so we can see the selection box
      if (globals.element_type == ELEMENT_LINE)
        {
        dX -= LINE_BORDER;
        dY -= LINE_BORDER;
        dwX += LINE_BORDER * 2;
        dwY += LINE_BORDER * 2;
        }

      var height = dwY + globals.caption_height * globals.height_multiple
      // there is a gap between the image and the caption
      if (globals.caption_height)
        height += GAP_BETWEEN_IMAGE_AND_CAPTION  * globals.height_multiple

      globals.ctx.rect(dX, dY, dwX, globals.element_type == ELEMENT_STAR ? dwX : height);

      globals.ctx.setLineDash([]);
      globals.ctx.strokeStyle = "white";

      // stroke in white first in case the element is blue or very dark (like black)
      globals.ctx.stroke();

      globals.ctx.setLineDash([5, 5]);
      globals.ctx.strokeStyle = "blue";

      // draw dashed line around it
      globals.ctx.stroke();

      }

    } // end of for each element

  globals.ctx.restore ()

} // end of draw_selection


function draw_main_image ()
{
  console.log ("Drawing " + "full-page-image")
  globals.ctx.drawImage (document.getElementById("full-page-image"), 0, 0)
  draw_selection()
} // end of draw_main_image

function keyDownHandler (event)
  {

  // Escape cancels edits - seems to not work unless you click on the page first
  if (event.code == 'Escape' && globals.edit_clicked)
    {
    ResetClicked () // put everything back

    // now redraw without the resizing boxes
    var mainImage = document.getElementById("full-page-image")
    globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas
    globals.ctx.globalAlpha = 1;
    draw_main_image ()

    // put button back to "Edit"
    globals.submit_edits_button.disabled = false;
    globals.submit_edits_button.value     = "Edit";

    // disable "Reset edits"
    globals.reset_edits_button.disabled = true;

    // can edit again later if we want
    globals.edit_clicked = false;

    // show message about ctrl+clicking again
    document.getElementById("ctrl_click_message").style.display = 'block'

    preventDefaults (event)
    } // end of Escape

  // Enter accepts edits
  else if (event.code == 'Enter' && globals.edit_clicked && globals.edits_done)
    {
    globals.submit_edits_button.click ()

    preventDefaults (event)
    } // end of Enter

  // Numpad+Plus goes into edit mode, or submits edits
  else if (event.code == 'NumpadAdd')
    {
    if (globals.submit_edits_button)
      globals.submit_edits_button.click()

    preventDefaults (event)
    } // end of Numpad Plus

  // Numpad+Minus refreshes the page
  else if (event.code == 'NumpadSubtract')
    {
    var refreshButton = document.getElementById('refresh_page_button')
    if (refreshButton)
      refreshButton.click()

    preventDefaults (event)
    } // end of Numpad Minus

  // Numpad+Star shows all pages
  else if (event.code == 'NumpadMultiply')
    {
    var showAllPagesButton = document.getElementById('show_all_pages')
    if (showAllPagesButton)
      showAllPagesButton.click()

    preventDefaults (event)
    } // end of Numpad Star

  } // end of keyDownHandler

function drawSelectionsAndBorders ()
{
  draw_main_image ()
  if (globals.edit_clicked)
    drawborders ()
} // end of drawSelectionsAndBorders

// when they select an item automatically expand the things you can do to save
// having to make an extra click
function SelectionClicked (event)
  {
  document.getElementById('selection_details').open = true
  drawSelectionsAndBorders ()
  return false;
  } // end of SelectionClicked


function clearSelections (event)
  {
  var filterTags = document.getElementsByClassName("selection_checkbox");
  for (var i = 0; i < filterTags.length; i++)
    {
     var item = filterTags.item(i);
     item.checked = false;
    } // end of for
  drawSelectionsAndBorders ()
  document.getElementById('selection_details').open = false
  return false;
  } // end of clearSelections

function setSelections (event)
  {
  var filterTags = document.getElementsByClassName("selection_checkbox");
  for (var i = 0; i < filterTags.length; i++)
    {
     var item = filterTags.item(i);
     item.checked = true;
    } // end of for
  drawSelectionsAndBorders ()
  document.getElementById('selection_details').open = true
  return false;
  } // end of setSelections

// see: https://stackoverflow.com/questions/51805395/navigator-clipboard-is-undefined

// return a promise
function copyToClipboard(textToCopy) {
    // navigator clipboard api needs a secure context (https)
    if (navigator.clipboard && window.isSecureContext) {
        // navigator clipboard api method'
        return navigator.clipboard.writeText(textToCopy);
    } else {
        // text area method
        let textArea = document.createElement("textarea");
        textArea.value = textToCopy;
        // make the textarea out of viewport
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        return new Promise((res, rej) => {
            // here the magic happens
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}

// for copying the output from Pandoc to the clipboard
function copyMarkdown ()
{
  var md_text = document.getElementById("markdown_text")

  copyToClipboard(md_text.textContent)
    .then(() => alert('Copied markdown to the Clipboard'))
    .catch(() => alert('Cannot copy to Clipboard, select and copy it yourself.'));

} // end of copyMarkdown

// here to fix up headings in the form **my heading** on a line on their own, to be ## my heading
function fixHeadings ()
{
  var md_text = document.getElementById("markdown_text").textContent
  md_text = md_text.replace (/\n\x2a\x2a([^\n\x2a]+)\x2a\x2a\n/g, '\n\n## $1\n\n')
  document.getElementById("markdown_text").textContent = md_text
} // end of fixHeadings

// see: https://www.smashingmagazine.com/2018/01/drag-drop-file-uploader-vanilla-js/

// for drag and drop of the DOCX file for uploading
function markdownConvertDrop (event)
{
  var markdown_convert_drop_zone = document.getElementById ('markdown_convert_drop_zone')

  if (event.dataTransfer.files.length)  // should be exactly one file, really
    {
    document.getElementById('markdown_convert_file_list').files = event.dataTransfer.files
    document.getElementById("markdown_convert_form").submit();
    }
  preventDefaults (event);
  markdown_convert_drop_zone.classList.remove('markdown-drag-over');
  markdown_convert_drop_zone.classList.add('markdown-not-drag-over');
} // end of markdownConvertDrop

function markdownConvertEnter (event)
  {
  var markdown_convert_drop_zone = document.getElementById ('markdown_convert_drop_zone')

  preventDefaults (event);
  markdown_convert_drop_zone.classList.add('markdown-drag-over');
  markdown_convert_drop_zone.classList.remove('markdown-not-drag-over');
  }   // end of markdownConvertEnter

function markdownConvertOver (event)
  {
  var markdown_convert_drop_zone = document.getElementById ('markdown_convert_drop_zone')

  preventDefaults (event);
  markdown_convert_drop_zone.classList.add('markdown-drag-over');
  markdown_convert_drop_zone.classList.remove('markdown-not-drag-over');
  } // end of markdownConvertOver

function markdownConvertLeave (event)
  {
  var markdown_convert_drop_zone = document.getElementById ('markdown_convert_drop_zone')

  preventDefaults (event);
  markdown_convert_drop_zone.classList.remove('markdown-drag-over');
  markdown_convert_drop_zone.classList.add('markdown-not-drag-over');
  } // end of markdownConvertLeave

function canvasDropImage (event)
{
  var mousex = event.offsetX
  var mousey = event.offsetY

  // find mouse position in mm
  var x = Math.round(mousex / globals.width_multiple);
  var y = Math.round(mousey / globals.height_multiple);

  // shift key snaps to the grid in the X direction
  if (event.shiftKey)
    {
    x = Math.round(x / grid_size_x) * grid_size_x;
//    y = Math.round(y / grid_size_y) * grid_size_y;
    }

  // update the location on the form
  document.getElementById('drop_image_x').value = x
  document.getElementById('drop_image_y').value = y

  document.getElementById('dragBorder').style.display = 'none'

  // submit the add image form

  if (event.dataTransfer.files.length)  // should be exactly one file, really
    {
    document.getElementById('drop_image_file').files = event.dataTransfer.files
    document.getElementById("drop_image_form").submit();
    }
  preventDefaults (event);
} // end of canvasDropImage

function canvasDragEnter (event)
  {
  preventDefaults (event);

  // set up the default width and height
  document.getElementById('dragBorder').style.width = (default_image_width * globals.width_multiple) + 'px'
  document.getElementById('dragBorder').style.height =  (default_image_width * globals.height_multiple) + 'px'
  document.getElementById('dragBorder').style ['outline-offset'] =  (default_image_border * globals.height_multiple) + 'px'

  // show the dragging border
  document.getElementById('dragBorder').style.display = 'block'

  } // end of canvasDragEnter

function canvasDragOver  (event)
  {
  preventDefaults (event);
  var mousex = event.offsetX
  var mousey = event.offsetY

  // find mouse position in mm
  var x = Math.round(mousex / globals.width_multiple);
  var y = Math.round(mousey / globals.height_multiple);

  // shift key snaps to the grid in the X direction
  if (event.shiftKey)
    {
    x = Math.round(x / grid_size_x) * grid_size_x;
//    y = Math.round(y / grid_size_y) * grid_size_y;
    }


  x *= globals.width_multiple;
  y *= globals.height_multiple;

  document.getElementById('dragBorder').style.left = x + 'px'
  document.getElementById('dragBorder').style.top = y + 'px'


  } // end of canvasDragOver

function canvasDragLeave (event)
  {
  preventDefaults (event);
  document.getElementById('dragBorder').style.display = 'none'
  } // end of canvasDragLeave

function dropOntoMainPage (event)
  {
  preventDefaults (event);
  console.log ('drop prevented')
  } // end of dropOntoMainPage

// START HERE

// Run the script after a short delay to ensure the DOM is fully loaded
setTimeout(() => {
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    init();
  } else {
    document.addEventListener('DOMContentLoaded', init);
  }
}, 500);

//init ();  // get our globals.canvas and context


document.addEventListener('keydown', keyDownHandler);

