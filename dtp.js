/*

Support functions, in Javascript, for the DTP system (see /hhs/dtp.php)


Copyright Â© 2019 Nick Gammon.

  Author: Nick Gammon <nick@gammon.com.au>
  Web:    http://www.gammon.com.au/
  Date:   November 2019

 PERMISSION TO DISTRIBUTE

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 and associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 LIMITATION OF LIABILITY

 The software is provided "as is", without warranty of any kind, express or implied,
 including but not limited to the warranties of merchantability, fitness for a particular
 purpose and noninfringement. In no event shall the authors or copyright holders be liable
 for any claim, damages or other liability, whether in an action of contract,
 tort or otherwise, arising from, out of or in connection with the software
 or the use or other dealings in the software.

  Note: The PHP file communicates with this module by passing down variables giving the element ID,
  element type and position of each element. The page width and page height are for converting from
  mm as used in the document and pixels as used on the screen.

  Example:

  var num_elements = 6;
  var page_width = 210;
  var page_height = 297;
  var grid_size_x = 8;
  var grid_size_y = 8;
  var elements = [
  [ 1, 1, 12, 23.04, 81, 76, 1, 0, 4, "cyan", "" ],
  [ 3, 3, 9, 227, 201, 227, 1, 0, 0.5, "black", "pink" ],
  [ 7, 5, 8, 8.08, 200, 17.04, 1, 0, 0, "", "" ],
  [ 11, 6, 74, 196, 145, 285, 0.83058823529412, 5, 1, "cyan", "#fff6d5" ],
  [ 3136, 1, 119, 189.04, 199, 279.04, 1, 0, 0, "", "red" ],
  [ 3137, 1, 158, 175.24, 200, 221.28, 1, 0, 0, "", "green" ],
  [ 3138, 1, 60, 3, 205, 151, 1, 0, 3, "red", "" ],
  ];

  Element array info as per "array position meanings" below. ie.

   [ ELEMENT_ID, ELEMENT_TYPE, STARTX, ENDX, ENDY, ASPECT_RATIO, CAPTION_HEIGHT,
     STROKE_WIDTH, "STROKE_COLOUR", "FILL_COLOUR" ],

*/

"use strict"

const BOX_SIZE = 10;   // size of corner boxes
const DRAGGING_BOX_SIZE = 30;  // width of globals.dragging box (height is BOX_SIZE)
const BOX_OPACITY = 1;
const BACKGROUND_OPACITY = 0.15;
const BACKGROUND_COLOUR = 'black';

// array position meanings (as generated by dtp.php)
const ELEMENT_ID     = 0;
const ELEMENT_TYPE   = 1;
const STARTX         = 2;
const STARTY         = 3;
const ENDX           = 4;
const ENDY           = 5;
const ASPECT_RATIO   = 6;
const CAPTION_HEIGHT = 7;
const STROKE_WIDTH   = 8;
const STROKE_COLOUR  = 9;
const FILL_COLOUR    = 10;

const LAST_ITEM = ENDY;  // must be last element in array (above)

// element types
const ELEMENT_RECTANGLE         = 1;
const ELEMENT_ELLIPSE           = 2;
const ELEMENT_LINE              = 3;
const ELEMENT_STAR              = 4;
const ELEMENT_TEXT              = 5;
const ELEMENT_IMAGE             = 6;
const ELEMENT_TEXT_CONTINUATION = 7;

// for the page grid
const GRID_SIZE_X = 8;
const GRID_SIZE_Y = 8;

// put our global variables here to make it clear they are global
var globals = [];

// Initialization: called on load of script
function init()
  {
  globals.canvas = document.getElementById("mycanvas");  // our globals.canvas

  if (globals.canvas)
    {
    globals.ctx = globals.canvas.getContext("2d");                 // our drawing context
    // convert width from mm into pixels as displayed on the page
    globals.width_multiple  = globals.canvas.width / page_width;
    globals.height_multiple = globals.canvas.height / page_height;

    // make a copy of element positions so we can reset to the beginning state
    globals.orig_elements = [];
    for (var i = 0; i < num_elements; i++)
      {
      globals.orig_elements [i] = [];
      for (var j = 0; j <= LAST_ITEM; j++)
        globals.orig_elements [i] [j] = elements [i] [j];
      }
    } // end of if globals.canvas exists

  // they haven't clicked the "Edit" button yet
  globals.edit_clicked = false;
  globals.edits_done   = false;
  globals.dragging     = false;

  // nor the "add new element" button
  globals.adding       = false;
  globals.started_dragging = false;

  submit_edits_button = document.getElementById("submit_edits_button");
  submit_edits_button.onclick = SubmitEditsClicked;

  // for adding elements by clicking and dragging
  globals.add_text_button = document.getElementById("add_text_button");
  globals.add_text_button.onclick = AddTextClicked;

  globals.add_heading_button = document.getElementById("add_heading_button");
  globals.add_heading_button.onclick = AddHeadingClicked;

  globals.add_continuation_button = document.getElementById("add_continuation_button");
  globals.add_continuation_button.onclick = AddContinuationClicked;

  globals.add_box_button = document.getElementById("add_box_button");
  globals.add_box_button.onclick = AddBoxClicked;

  globals.add_vline_button = document.getElementById("add_vline_button");
  globals.add_vline_button.onclick = AddVlineClicked;

  globals.add_hline_button = document.getElementById("add_hline_button");
  globals.add_hline_button.onclick = AddHlineClicked;

  globals.add_image_button = document.getElementById("add_image_button");
  globals.add_image_button.onclick = AddImageClicked;

  globals.add_ellipse_button = document.getElementById("add_ellipse_button");
  globals.add_ellipse_button.onclick = AddEllipseClicked;

  globals.add_star_button = document.getElementById("add_star_button");
  globals.add_star_button.onclick = AddStarClicked;

  // see if our main image has loaded, if not set up a handler for it
  var image = document.getElementById('full-page-image')
  var isLoaded = image.complete && image.naturalHeight !== 0;

  if (isLoaded)
    draw_main_image ()
  else
    image.onload = draw_main_image

  } // end of init

// draw one of the four corner boxes
function drawCornerBox (x, y)
  {
  globals.ctx.beginPath();
  globals.ctx.rect((x * globals.width_multiple)   - BOX_SIZE / 2,
           (y * globals.height_multiple)  - BOX_SIZE / 2,
           BOX_SIZE,
           BOX_SIZE
           );
  globals.ctx.fillStyle = "green";
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.fill ();
  } // end of drawCornerBox

// fill with different colours to make the different elements stand out from each other
var movedFillColours = [
  'Red',
  'Green',
  'Blue',
  'Cyan',
  'Magenta',
  'Yellow',
  'Black',
];

// extract out one array element into global variables
function getElementDetails (element)
  {
  // extract out fields from database
  globals.element_id    = element [ELEMENT_ID];
  globals.element_type  = element [ELEMENT_TYPE];
  globals.startX        = element [STARTX];
  globals.startY        = element [STARTY];
  globals.endX          = element [ENDX];
  globals.endY          = element [ENDY];
  globals.aspect_ratio  = element [ASPECT_RATIO];
  globals.caption_height= element [CAPTION_HEIGHT];
  globals.stroke_width  = element [STROKE_WIDTH];
  globals.stroke_colour = element [STROKE_COLOUR];
  globals.fill_colour   = element [FILL_COLOUR];

  } // end of getElementDetails

// draw element borders, plus resizing and moving handles
function drawborders ()
{
var mainImage = document.getElementById("full-page-image")

globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas

globals.ctx.globalAlpha = 0.4;
draw_main_image ()
globals.ctx.globalAlpha = 1;

// first draw all the images

for (var i = 0; i < num_elements; i++)
  {
  // get *this* element
  getElementDetails (elements [i]);

  var origX, origY, origwX, origwY, dX, dY, dwX, dwY;

  // original (source) of the image
  origX = globals.orig_elements [i] [STARTX]  * globals.width_multiple
  origY = globals.orig_elements [i] [STARTY]  * globals.height_multiple
  origwX = (globals.orig_elements [i] [ENDX]  - globals.orig_elements [i] [STARTX])  * globals.width_multiple
  origwY = (globals.orig_elements [i] [ENDY] - globals.orig_elements [i] [STARTY])  * globals.height_multiple

  // current (destination) image
  dX = globals.startX * globals.width_multiple
  dY = globals.startY * globals.height_multiple
  dwX = (globals.endX - globals.startX) * globals.width_multiple
  dwY = (globals.endY - globals.startY) * globals.height_multiple

  // fill the entire element
  globals.ctx.beginPath();

  globals.ctx.rect(dX, dY, dwX, dwY);

  // fill box if moved from original position
  if (ElementChanged (i))
    {
    globals.ctx.fillStyle = 'white';
//    globals.ctx.fillStyle = movedFillColours [i % movedFillColours.length];
    globals.ctx.globalAlpha = BACKGROUND_OPACITY;  // low opacity fill
    globals.ctx.globalAlpha = BACKGROUND_OPACITY * (Math.floor (i / movedFillColours.length) + 1);
    globals.ctx.fill();
    }

  // draw its image
  globals.ctx.globalAlpha = 1;
  globals.ctx.save ()

  // rectangles, text and images can have fill or strokes
  if (globals.element_type == ELEMENT_RECTANGLE ||
      globals.element_type == ELEMENT_TEXT ||
      globals.element_type == ELEMENT_TEXT_CONTINUATION ||
      globals.element_type == ELEMENT_IMAGE)
    {
    globals.ctx.beginPath()
    globals.ctx.rect(dX, dY, dwX, dwY)

    if (globals.fill_colour)
      {
      globals.ctx.fillStyle = globals.fill_colour;
      globals.ctx.fill();
      } // end of having a fill

    if (globals.stroke_width > 0 && globals.stroke_colour)
      {
      globals.ctx.strokeStyle = globals.stroke_colour
      globals.ctx.lineWidth = globals.stroke_width
      globals.ctx.stroke();
      } // end of having a stroke
    }

  globals.ctx.restore ()

  globals.ctx.save ()

  // stretch images to fit but not other things
  if (globals.element_type == ELEMENT_IMAGE)
    {
    var thisImage = document.getElementById("source_image_" + globals.element_id)
    var dwXadj = Math.min (dwY * globals.aspect_ratio, dwX)
    var dwYadj = Math.min (dwX / globals.aspect_ratio, dwY)

    globals.ctx.drawImage (thisImage, dX + (dwX - dwXadj) / 2, dY  + (dwY - dwYadj) / 2, dwXadj, dwYadj)
    } // end of ELEMENT_IMAGE
  else if ((globals.element_type == ELEMENT_TEXT || globals.element_type == ELEMENT_TEXT_CONTINUATION)
          && ElementChanged (i))
    {
    globals.ctx.strokeStyle = 'lightgray'
    globals.ctx.lineWidth = 10
    // draw some thick lines to indicate text
    for (var y = dY + 10; y < (dY + dwY); y += 20)
      {
      globals.ctx.beginPath()
      globals.ctx.moveTo (dX, y)
      globals.ctx.lineTo (dX + dwX, y)
      globals.ctx.stroke();
      } // end of for each thick line

    }   // end of ELEMENT_TEXT or ELEMENT_TEXT_CONTINUATION
  else if (globals.element_type == ELEMENT_RECTANGLE)
    {
    // do nothing, we already drew it
    } // end of ELEMENT_RECTANGLE
  else if (globals.element_type == ELEMENT_LINE)
    {
    if (globals.stroke_width > 0 && globals.stroke_colour)
      {
      globals.ctx.beginPath()
      globals.ctx.strokeStyle = globals.stroke_colour
      globals.ctx.lineWidth = globals.stroke_width
      globals.ctx.moveTo (dX, dY)
      globals.ctx.lineTo (dX + dwX, dY + dwY)
      globals.ctx.stroke();
      } // end of having a stroke

    } // end of ELEMENT_LINE
  else if (globals.element_type == ELEMENT_ELLIPSE)
    {
    globals.ctx.beginPath()
    globals.ctx.ellipse(dX + (dwX / 2), dY + (dwY / 2), dwX / 2, dwY / 2, 0, 0, Math.PI * 2)

    if (globals.fill_colour)
      {
      globals.ctx.fillStyle = globals.fill_colour;
      globals.ctx.fill();
      } // end of having a fill

    if (globals.stroke_width > 0 && globals.stroke_colour)
      {
      globals.ctx.strokeStyle = globals.stroke_colour
      globals.ctx.lineWidth = globals.stroke_width
      globals.ctx.stroke();
      } // end of having a stroke

    } // end of ELEMENT_ELLIPSE
  else
    globals.ctx.drawImage (mainImage, origX, origY, origwX, origwY, dX, dY, origwX, origwY)

  globals.ctx.restore ()

  }


for (var i = 0; i < num_elements; i++)
  {
  // get *this* element
  getElementDetails (elements [i]);

  var dX, dY, dwX, dwY;

  dX = globals.startX * globals.width_multiple
  dY = globals.startY * globals.height_multiple
  dwX = (globals.endX - globals.startX) * globals.width_multiple
  dwY = (globals.endY - globals.startY) * globals.height_multiple

  // stroke the entire element (box around it)
  globals.ctx.beginPath();

  globals.ctx.rect(dX, dY, dwX, dwY + globals.caption_height * globals.height_multiple);

  // draw box around it
  globals.ctx.strokeStyle = "green";
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.stroke();

  // corner boxes (small boxes at corners) TOP LEFT
  drawCornerBox (globals.startX, globals.startY);

  // lines only have two corners
  if (globals.element_type != ELEMENT_LINE)
    {
    drawCornerBox (globals.endX, globals.startY);  // TOP RIGHT
    drawCornerBox (globals.startX, globals.endY);  // BOTTOM LEFT
    }

  // corner box BOTTOM RIGHT
  drawCornerBox (globals.endX, globals.endY);

/*
  // draw globals.dragging box
  globals.ctx.beginPath();
  var x = globals.startX + ((globals.endX - globals.startX) / 2);  // half way along
  globals.ctx.rect((x * globals.width_multiple) - (DRAGGING_BOX_SIZE / 2),
           (globals.startY * globals.height_multiple)  - BOX_SIZE / 2,
           DRAGGING_BOX_SIZE,
           BOX_SIZE
           );
  globals.ctx.globalAlpha = BOX_OPACITY;
  globals.ctx.fillStyle = "green";
  globals.ctx.fill ();
*/

  } // end of for each element

  // now the grid

  globals.ctx.globalAlpha = 0.5;
  globals.ctx.strokeStyle = 'gray'

  // vertical grid (each X position - vertical lines)
  for (var x = GRID_SIZE_X  * globals.width_multiple; x < globals.canvas.width; x += GRID_SIZE_X * globals.width_multiple)
    {
     globals.ctx.beginPath();
     globals.ctx.moveTo(x, GRID_SIZE_Y * globals.height_multiple);
     // don't overshoot last horizontal grid
     var y2 = globals.canvas.height - ((GRID_SIZE_Y  - 1 ) * globals.height_multiple)
     y2 = Math.floor (y2 / (GRID_SIZE_Y  * globals.height_multiple)) *  (GRID_SIZE_Y  * globals.height_multiple)
     globals.ctx.lineTo(x, y2)
     globals.ctx.stroke();
    }

  // horizontal grid (each y position - horizontal lines)
  for (var y = GRID_SIZE_Y * globals.height_multiple; y < globals.canvas.height; y += GRID_SIZE_Y * globals.height_multiple)
    {
     globals.ctx.beginPath();
     globals.ctx.moveTo(GRID_SIZE_X * globals.width_multiple , y);
     // don't overshoot last vertical grid
     var x2 = globals.canvas.width - ((GRID_SIZE_X  - 1 ) * globals.width_multiple)
     x2 = Math.floor (x2 / (GRID_SIZE_X  * globals.width_multiple)) *  (GRID_SIZE_X  * globals.width_multiple)
     globals.ctx.lineTo(x2, y)
     globals.ctx.stroke();
    }

  globals.ctx.globalAlpha = 1;

} // end of drawborders

// helper function to reset one element back to its original position
function ResetOneElement (which)
  {

  // copy values back
  for (var j = 0; j <= LAST_ITEM; j++)
    elements [which] [j] = globals.orig_elements [which] [j];

  // put the HTML values back
  globals.element_id = elements [which] [ELEMENT_ID];

  // fix up globals.startX
  globals.startXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startX"));
  globals.startXonPage [0].value = elements [which] [STARTX];

  // fix up globals.startY
  globals.startYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startY"));
  globals.startYonPage [0].value = elements [which] [STARTY];

  // fix up globals.endX
  globals.endXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endX"));
  globals.endXonPage [0].value = elements [which] [ENDX];

  // fix up globals.endY
  globals.endYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endY"));
  globals.endYonPage [0].value = elements [which] [ENDY];

  } // end of ResetOneElement

// here when the "Reset" button clicked - put everything back to how it was
function ResetClicked (event)
{
  submit_edits_button = document.getElementById("submit_edits_button");
  submit_edits_button.disabled = true;

  reset_edits_button = document.getElementById("reset_edits_button");
  reset_edits_button.disabled = true;

  // reset all elements
  for (var i = 0; i < num_elements; i++)
    ResetOneElement (i);

  drawborders ();   // redraw original positions
  globals.edits_done = false;
  return false;     // don't submit form
} // end of ResetClicked

// here when the "Edit" / "Submit edits" button is clicked
function SubmitEditsClicked (event)
{
  // don't edit and add stuff at the same time
  if (globals.adding)
    return false;

  if (!globals.edit_clicked)
    {
    globals.edit_clicked          = true;
    submit_edits_button           = document.getElementById("submit_edits_button");
    submit_edits_button.value     = "Submit edits";
    submit_edits_button.disabled  = true;  // nothing edited yet
    drawborders ();
    event.preventDefault();
    return false;   // don't submit yet
    }
  return true;  // submit form now
} // end of SubmitEditsClicked

function AddElementClicked (adding_type, button)
{
  // don't edit and add stuff at the same time
  if (globals.edit_clicked)
    return false;

  if (!globals.adding)
    {
    globals.adding            = true
    globals.started_dragging  = false
    globals.adding_type     = adding_type
    globals.canvas.style.cursor = 'crosshair';
    globals.add_element_button = button
    globals.add_element_button.disabled  = true;  // can't click it again

    // save type of add
    var add_element_type = document.getElementsByName("add_element_type");
    add_element_type [0].value = globals.adding_type

    document.getElementById('editing_notes').innerHTML = 'SHIFT to snap to grid, CTRL to cancel adding an element'
    }
} // end of AddElementClicked

// here when the "Add text block" button is clicked
function AddTextClicked (event)
  {
  AddElementClicked ('text', globals.add_text_button)
  return false;   // don't submit yet
  } // end of AddTextClicked

// here when the "Add heading block" button is clicked
function AddHeadingClicked (event)
  {
  AddElementClicked ('heading', globals.add_heading_button)
  return false;   // don't submit yet
  } // end of AddHeadingClicked

// here when the "Add text continuation block" button is clicked
function AddContinuationClicked (event)
  {
  AddElementClicked ('continuation', globals.add_continuation_button)
  return false;   // don't submit yet
  } // end of AddContinuationClicked

// here when the "Add box" button is clicked
function AddBoxClicked (event)
  {
  AddElementClicked ('box', globals.add_box_button)
  return false;   // don't submit yet
  } // end of AddBoxClicked

// here when the "Add vertical line" button is clicked
function AddVlineClicked (event)
  {
  AddElementClicked ('vertical line', globals.add_vline_button)
  return false;   // don't submit yet
  } // end of AddVlineClicked

// here when the "Add horizontal line" button is clicked
function AddHlineClicked (event)
  {
  AddElementClicked ('horizontal line', globals.add_hline_button)
  return false;   // don't submit yet
  } // end of AddHlineClicked

// here when the "Add image" button is clicked
function AddImageClicked (event)
  {
  AddElementClicked ('image', globals.add_image_button)
  return false;   // don't submit yet
  } // end of AddImageClicked

// here when the "Add ellipse line" button is clicked
function AddEllipseClicked (event)
  {
  AddElementClicked ('ellipse', globals.add_ellipse_button)
  return false;   // don't submit yet
  } // end of AddEllipseClicked

// here when the "Add star" button is clicked
function AddStarClicked (event)
  {
  AddElementClicked ('star', globals.add_star_button)
  return false;   // don't submit yet
  } // end of AddStarClicked

// returns true if this element has globals.changed from its original position
function ElementChanged (which)
  {
  return elements [which] [STARTX] != globals.orig_elements [which] [STARTX] ||
         elements [which] [ENDX]   != globals.orig_elements [which] [ENDX] ||
         elements [which] [STARTY] != globals.orig_elements [which] [STARTY] ||
         elements [which] [ENDY]   != globals.orig_elements [which] [ENDY];
  } // end of ElementChanged

// see if the page has globals.changed by checking all elements
function CheckIfPageChanged ()
  {
  globals.changed = false;  // no changes yet

  // check each element
  for (var i = 0; i < num_elements; i++)
    if (ElementChanged (i))
      globals.changed = true;

  if (globals.changed)
    {
    submit_edits_button.disabled  = false;
    reset_edits_button.disabled   = false;
    reset_edits_button.onclick    = ResetClicked;
    globals.edits_done            = true;
    }
  else
    {
    // no changes? make sure submit and reset buttons are disabled
    // - this is for the situation where you make a change and then change it back
    submit_edits_button.disabled  = true;
    reset_edits_button.disabled   = true;
    reset_edits_button.onclick    = null;
    globals.edits_done            = false;
    }
  } // end of CheckIfPageChanged

// set the appropriate mouse cursor shape depending on what it is hovering over, if anything
function SetMouseCursor (event)
  {
  var mousex = event.offsetX;
  var mousey = event.offsetY;

  // find active element, assuming we can see them (edit button has been clicked)
  if (globals.edit_clicked)
    {
    // go backwards so that the higher (on top) one gets selected before the one underneath
    for (var i = num_elements - 1; i >= 0; i--)
      {
      globals.activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);
      // top left?
      if (mouseInBox (mousex, mousey, globals.startX, globals.startY, BOX_SIZE, BOX_SIZE))
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // top right?
      else if (mouseInBox (mousex, mousey, globals.endX, globals.startY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // bottom left?
      else if (mouseInBox (mousex, mousey, globals.startX, globals.endY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      // bottom right?
      else if (mouseInBox (mousex, mousey, globals.endX, globals.endY, BOX_SIZE, BOX_SIZE))
        {
        globals.canvas.style.cursor = 'nwse-resize';
        return;
        }
      } // end of for each element

    // and now check the dragging area last because the selection boxes take precedence
    // go backwards so that the higher (on top) one gets selected before the one underneath
    for (var i = num_elements - 1; i >= 0; i--)
      {
      globals.activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);
      if (mouseInElement (mousex, mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
        {
        globals.canvas.style.cursor = 'move';
        return;
        }
      } // end of for each element

    }   // of edit button active

  // edit button or not, we can double-click elements

  // check the entire element rectangle
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    if (mouseInElement (mousex, mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
      {
      // found the element!
      globals.canvas.style.cursor = 'pointer';
      return;
      }
    } // end of for each element

  // mouse isn't anywhere interesting
  globals.canvas.style.cursor = 'default';

  } // end of SetMouseCursor

// mouse move handler - resize the element box (or move it) assuming we had a previous mouse down
function onMouseMove(event)
{
  globals.mousex = event.offsetX;
  globals.mousey = event.offsetY;

  if (globals.adding)
    {
    globals.canvas.style.cursor = 'crosshair';

    if (globals.started_dragging)
      {
      var mainImage = document.getElementById("full-page-image")
      globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas

      globals.ctx.globalAlpha = 0.8;
      draw_main_image ()
      globals.ctx.globalAlpha = 1;

      // find new position in mm
      var x = Math.round(globals.mousex / globals.width_multiple);
      var y = Math.round(globals.mousey / globals.height_multiple);

      // shift key snaps to the grid
      if (event.shiftKey)
        {
        x = Math.round(x / grid_size_x) * grid_size_x;
        y = Math.round(y / grid_size_y) * grid_size_y;
        }

      // convert back to pixels
      x *= globals.width_multiple
      y *= globals.height_multiple

      // draw its outline
      globals.ctx.globalAlpha = 1;
      globals.ctx.save ()
      globals.ctx.beginPath()
      globals.ctx.rect(globals.box_startx, globals.box_starty,
                      x - globals.box_startx,
                      y - globals.box_starty)
      globals.ctx.strokeStyle = "green"
      globals.ctx.lineWidth = 3
      globals.ctx.stroke();
      globals.ctx.fillStyle = "green";
      globals.ctx.globalAlpha = 0.2;
      globals.ctx.fill ();
      globals.ctx.restore ()


      // fix up startX
      var add_element_startX = document.getElementsByName("add_element_startX");
      add_element_startX [0].value = globals.box_startx / globals.width_multiple;

      // fix up startY
      var add_element_startY = document.getElementsByName("add_element_startY");
      add_element_startY [0].value = globals.box_starty / globals.height_multiple;

      // fix up endX
      var add_element_endX = document.getElementsByName("add_element_endX");
      add_element_endX [0].value = x / globals.width_multiple;

       // fix up endY
      var add_element_endY = document.getElementsByName("add_element_endY");
      add_element_endY [0].value = y / globals.height_multiple;

      } // end of currently dragging

    return;
    }

  // if not globals.dragging, change the mouse to indicate what we *can* do if we click
  if (!globals.dragging)
  {
  SetMouseCursor (event);
  return
  }

  // if globals.dragging (mouse down previously) update the element's position depending on where we move to

  // find new position in mm
  var x = Math.round(globals.mousex / globals.width_multiple);
  var y = Math.round(globals.mousey / globals.height_multiple);

  // shift key snaps to the grid
  if (event.shiftKey)
    {
    x = Math.round(x / grid_size_x) * grid_size_x;
    y = Math.round(y / grid_size_y) * grid_size_y;
    }

  globals.element_type = elements [globals.activeElement] [ELEMENT_TYPE];

  // update element - depending on which corner was being moved

  // top left
  if (globals.activeCorner == 'topleft' && globals.element_type == ELEMENT_LINE)
    {
    // lines can line up vertically and horizontally
    if (x <= elements [globals.activeElement] [ENDX] && y <= elements [globals.activeElement] [ENDY])
      {
      elements [globals.activeElement] [STARTX] = x;
      elements [globals.activeElement] [STARTY] = y;
      }
    }
  else if (globals.activeCorner == 'topleft' && globals.element_type != ELEMENT_LINE)
    {
    if (x < elements [globals.activeElement] [ENDX] && y < elements [globals.activeElement] [ENDY])
      {
      elements [globals.activeElement] [STARTX] = x;
      elements [globals.activeElement] [STARTY] = y;
      }
    }

  // top right
  else if (globals.activeCorner == 'topright')
    {
    if (x > elements [globals.activeElement] [STARTX] && y < elements [globals.activeElement] [ENDY])
      {
      elements [globals.activeElement] [ENDX] = x;
      elements [globals.activeElement] [STARTY] = y;
      }
    }

  // bottom left
  else if (globals.activeCorner == 'bottomleft')
    {
    if (x < elements [globals.activeElement] [ENDX] && y > elements [globals.activeElement] [STARTY])
      {
      elements [globals.activeElement] [STARTX] = x;
      elements [globals.activeElement] [ENDY] = y;
      }
    }

 // bottom right
 else if (globals.activeCorner == 'bottomright' && globals.element_type == ELEMENT_LINE)
    {
    // lines can line up vertically and horizontally
    if (x >= elements [globals.activeElement] [STARTX] && y >= elements [globals.activeElement] [STARTY])
      {
      elements [globals.activeElement] [ENDX] = x;
      elements [globals.activeElement] [ENDY] = y;
      }
    }
 else if (globals.activeCorner == 'bottomright' && globals.element_type != ELEMENT_LINE)
    {
    if (x > elements [globals.activeElement] [STARTX] && y > elements [globals.activeElement] [STARTY])
      {
      elements [globals.activeElement] [ENDX] = x;
      elements [globals.activeElement] [ENDY] = y;
      }
    }

  // drag box (reposition)
  else if (globals.activeCorner == 'drag')
    {
    var deltaX = Math.round((globals.dragMouseX - event.offsetX) / globals.width_multiple);
    var deltaY = Math.round((globals.dragMouseY - event.offsetY) / globals.height_multiple);

    var new_x = globals.dragStartX - deltaX;
    var new_y = globals.dragStartY - deltaY;
    var width = elements [globals.activeElement]  [ENDX] - elements [globals.activeElement] [STARTX];
    var height = elements [globals.activeElement] [ENDY] - elements [globals.activeElement] [STARTY];

    // shift key snaps to the grid
    if (event.shiftKey)
      {
      new_x = Math.round(new_x / grid_size_x) * grid_size_x;
      new_y = Math.round(new_y / grid_size_y) * grid_size_y;
      }

    elements [globals.activeElement] [STARTX] = new_x;
    elements [globals.activeElement] [STARTY] = new_y;
    elements [globals.activeElement] [ENDX]   = new_x + width;
    elements [globals.activeElement] [ENDY]   = new_y + height;
    }

  drawborders ();

  // update form ready for them to post it

  // turn element array number into an element ID
  globals.element_id = elements [globals.activeElement] [ELEMENT_ID];

  // fix up globals.startX
  globals.startXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startX"));
  globals.startXonPage [0].value = elements [globals.activeElement] [STARTX];

  // fix up globals.startY
  globals.startYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_startY"));
  globals.startYonPage [0].value = elements [globals.activeElement] [STARTY];

  // fix up globals.endX
  globals.endXonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endX"));
  globals.endXonPage [0].value = elements [globals.activeElement] [ENDX];

  // fix up globals.endY
  globals.endYonPage = document.getElementsByName("element_".concat (globals.element_id.toString (10), "_endY"));
  globals.endYonPage [0].value = elements [globals.activeElement] [ENDY];

  submit_edits_button = document.getElementById("submit_edits_button");
  reset_edits_button = document.getElementById("reset_edits_button");

  // check a change has actually been made before activating the submit and reset buttons
  CheckIfPageChanged ();


} // end of onMouseMove

// test if the mouse is inside one of the globals.dragging boxes
function mouseInBox (mousex, mousey, x, y, hsize, vsize)
  {
  if (mousex < (x * globals.width_multiple) - hsize / 2)
    return false;  // too far left
  if (mousex > (x * globals.width_multiple) + hsize / 2)
    return false;  // too far right
  if (mousey < (y * globals.height_multiple) - vsize / 2)
    return false;  // too far up
  if (mousey > (y * globals.height_multiple) + vsize / 2)
    return false;  // too far down
  return true;
  } // end of mouseInBox

// test if the mouse is inside one of the elements
function mouseInElement (mousex, mousey, sx, sy, ex, ey)
  {
  // a line, being infinitely thin, will appear to always match
  // so, make it one pixel wide.

  if (Math.abs (sx - ex) < 2)
    ex++;
  if (Math.abs (sy - ey) < 2)
    ey++;

  if (mousex < (sx * globals.width_multiple))
    return false;  // too far left
  if (mousex > (ex * globals.width_multiple))
    return false;  // too far right
  if (mousey < (sy * globals.height_multiple))
    return false;  // too far up
  if (mousey > (ey * globals.height_multiple))
    return false;  // too far down
  return true;
  } // end of mouseInElement

// mouse down event - set up for globals.dragging somewhere
function onMouseDown(event)
{
  globals.found   = false;
  globals.mousex  = event.offsetX;
  globals.mousey  = event.offsetY;

  // Ctrl+Click to toggle selection in the list on the right
  if (!globals.adding && !globals.edit_clicked && event.ctrlKey)
    {
    // check the entire element rectangle
    // go backwards so that the higher (on top) one gets selected before the one underneath
    for (var i = num_elements - 1; i >= 0; i--)
      {
      globals.activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);

      if (mouseInElement (globals.mousex, globals.mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
        {
        // found the element!
        var selection_to_click = document.getElementById("checkbox_to_select_".concat (globals.element_id));
        if (!selection_to_click)
          return;   // can't find button

        selection_to_click.click();    // activate it
        return;
        }
      } // end of for each element

    return;
    }


  if (globals.started_dragging)
    return;

  // HERE for ADDING NEW ELEMENTS

  if (globals.adding)
    {
    globals.started_dragging = true;

    // find new position in mm
    var x = Math.round(globals.mousex / globals.width_multiple);
    var y = Math.round(globals.mousey / globals.height_multiple);

    // shift key snaps to the grid
    if (event.shiftKey)
      {
      x = Math.round(x / grid_size_x) * grid_size_x;
      y = Math.round(y / grid_size_y) * grid_size_y;
      }

    // convert back to pixels
    x *= globals.width_multiple
    y *= globals.height_multiple

    globals.box_startx = x
    globals.box_starty = y
    return
    } // end of adding an element


  // HERE for MOVING EXISTING ELEMENTS

  // mouse down isn't active until we can see the handler boxes
  if (!globals.edit_clicked)
    return;

  // find active element
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);
    // top left?
    if (mouseInBox (globals.mousex, globals.mousey, globals.startX, globals.startY, BOX_SIZE, BOX_SIZE))
      {
      globals.activeCorner = 'topleft';
      globals.found = true;
      break;
      }
    // top right?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.endX, globals.startY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
      {
      globals.activeCorner = 'topright';
      globals.found = true;
      break;
      }
    // bottom left?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.startX, globals.endY, BOX_SIZE, BOX_SIZE) && globals.element_type != ELEMENT_LINE)
      {
      globals.activeCorner = 'bottomleft';
      globals.found = true;
      break;
      }
    // bottom right?
    else if (mouseInBox (globals.mousex, globals.mousey, globals.endX, globals.endY, BOX_SIZE, BOX_SIZE))
      {
      globals.activeCorner = 'bottomright';
      globals.found = true;
      break;
      }
    // and now check the globals.dragging box
    else if (mouseInElement (globals.mousex, globals.mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
      {
      globals.activeCorner = 'drag';
      // remember where we clicked so we can get a delta location
      globals.dragMouseX = globals.mousex;
      globals.dragMouseY = globals.mousey;
      // remember where it was when we clicked
      globals.dragStartX = elements [globals.activeElement] [STARTX];
      globals.dragStartY = elements [globals.activeElement] [STARTY];
      globals.dragEndX   = elements [globals.activeElement] [ENDX];
      globals.dragEndY   = elements [globals.activeElement] [ENDY];
      globals.found = true;
      break;
      }

    } // end of for each element

  if (!globals.found)
    return;

  if (globals.activeCorner == 'drag')
    globals.canvas.style.cursor = 'move';
  else
    globals.canvas.style.cursor = 'nwse-resize';

  globals.dragging = true;

  document.getElementById('editing_notes').innerHTML = 'SHIFT to snap to grid, CTRL to reset position.<br>'
     + 'Text (indicated by grey bars) does not dynamically reflow.<br>'
     + 'Not all styles are applied while editing (eg. opacity, dotted lines).'

} // end of onMouseDown

// mouse up handler - cancel ability to drag
function onMouseUp(event)
  {

  document.getElementById('editing_notes').innerHTML = '';

  if (globals.adding)
    {
    globals.adding = false

    // if Ctrl pressed, do nothing
    if (event.ctrlKey || !globals.started_dragging)
      {
      globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas
      globals.ctx.globalAlpha = 1;
      draw_main_image ()
      globals.add_element_button.disabled  = false
      return;
      }

    globals.started_dragging = false;
    document.getElementById("add_element_box").submit();
    return
    }


  // ctrl key means discard moves and reset to defaults
  if (globals.dragging && event.ctrlKey && globals.activeCorner)
    {
    ResetOneElement (globals.activeElement);  // put the current element back to its default position
    CheckIfPageChanged ();
    drawborders ();     // redraw page
    }

  globals.activeCorner  = '';
  globals.dragging      = false;
  SetMouseCursor (event);
  } // end of onMouseUp

// double-click in an element box edits that element (eg. to change the text)
function onDoubleClick(event)
  {
  var mousex = event.offsetX;
  var mousey = event.offsetY;

  if (globals.edits_done)
    {
    alert ("You have un-saved position edits - submit them or reset them.");
    return;
    }

  // check the globals.dragging boxes first in case a small element is inside a larger one
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    // let them double-click in the title box in case it is hard to find the element (eg. a line)
    if (mouseInBox (mousex, mousey, globals.startX + (globals.endX - globals.startX) / 2, globals.startY, DRAGGING_BOX_SIZE, BOX_SIZE))
      {
      var button_to_click = document.getElementById("link_to_edit_element_".concat (globals.element_id));
      if (!button_to_click)
        return;   // can't find button
      button_to_click.click();    // activate it
      return;
      }
    } // end of for each element

  // now check the entire element rectangle
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (var i = num_elements - 1; i >= 0; i--)
    {
    globals.activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    if (mouseInElement (mousex, mousey, globals.startX, globals.startY, globals.endX, globals.endY + globals.caption_height))
      {
      // found the element!
      var button_to_click = document.getElementById("link_to_edit_element_".concat (globals.element_id));
      if (!button_to_click)
        return;   // can't find button

      button_to_click.click();    // activate it
      return;
      }
    } // end of for each element

  } // end of onDoubleClick

function draw_selection ()
{
  const LINE_BORDER = 6;
  globals.ctx.save ()

  globals.ctx.globalAlpha = 1;
  globals.ctx.setLineDash([5, 5]);
  globals.ctx.lineWidth = 2;
  globals.ctx.strokeStyle = "blue";

  for (var i = 0; i < num_elements; i++)
    {
    // get *this* element
    getElementDetails (elements [i]);

    var dX, dY, dwX, dwY;

    dX = globals.startX * globals.width_multiple
    dY = globals.startY * globals.height_multiple
    dwX = (globals.endX - globals.startX) * globals.width_multiple
    dwY = (globals.endY - globals.startY) * globals.height_multiple

    var element_checkbox = document.getElementById("checkbox_to_select_".concat (globals.element_id));

    if (element_checkbox && element_checkbox.checked)
      {
      // stroke the entire element (box around it)
      globals.ctx.beginPath();

      // make lines bigger so we can see the selection box
      if (globals.element_type == ELEMENT_LINE)
        {
        dX -= LINE_BORDER;
        dY -= LINE_BORDER;
        dwX += LINE_BORDER * 2;
        dwY += LINE_BORDER * 2;
        }

      var height = dwY + globals.caption_height * globals.height_multiple
      globals.ctx.rect(dX, dY, dwX, globals.element_type == ELEMENT_STAR ? dwX : height);

      // draw box around it
      globals.ctx.stroke();
      }

    } // end of for each element

  globals.ctx.restore ()

} // end of draw_selection

function draw_main_image ()
{
  globals.ctx.drawImage (document.getElementById("full-page-image"), 0, 0)
  draw_selection ()
} // end of draw_main_image

function keyDownHandler (event)
  {

  // Escape cancels edits - seems to not work unless you click on the page first
  if (event.code == 'Escape' && globals.edit_clicked)
    {
    ResetClicked () // put everything back

    // now redraw without the resizing boxes
    var mainImage = document.getElementById("full-page-image")
    globals.ctx.clearRect(0, 0, globals.canvas.width, globals.canvas.height);  // clear globals.canvas
    globals.ctx.globalAlpha = 1;
    draw_main_image ()

    // put button back to "Edit"
    var submit_edits_button = document.getElementById("submit_edits_button");
    submit_edits_button.disabled = false;
    submit_edits_button.value     = "Edit";

    // disable "Reset edits"
    var reset_edits_button = document.getElementById("reset_edits_button");
    reset_edits_button.disabled = true;

    // can edit again later if we want
    globals.edit_clicked = false;

    event.preventDefault();
    return
    }

  // Enter accepts edits
  if (event.code == 'Enter' && globals.edit_clicked && globals.edits_done)
    {
    var submit_edits_button  = document.getElementById("submit_edits_button");
    submit_edits_button.click ()

    event.preventDefault();
    return
    }


  } // end of keyDownHandler

function drawSelectionsAndBorders ()
{
  draw_main_image ()
  if (globals.edit_clicked)
    drawborders ()
} // end of drawSelectionsAndBorders

// when they select an item automatically expand the things you can do to save
// having to make an extra click
function SelectionClicked (event)
  {
  document.getElementById('selection_details').open = true
  drawSelectionsAndBorders ()
  return false;
  } // end of SelectionClicked


function clearSelections (event)
  {
  var filterTags = document.getElementsByClassName("selection_checkbox");
  for (var i = 0; i < filterTags.length; i++)
    {
     var item = filterTags.item(i);
     item.checked = false;
    } // end of for
  drawSelectionsAndBorders ()
  return false;
  } // end of clearSelections

function setSelections (event)
  {
  var filterTags = document.getElementsByClassName("selection_checkbox");
  for (var i = 0; i < filterTags.length; i++)
    {
     var item = filterTags.item(i);
     item.checked = true;
    } // end of for
  drawSelectionsAndBorders ()
  return false;
  } // end of setSelections


// START HERE

init ();  // get our globals.canvas and context

if (globals.canvas)
  {
  // mouse handlers
  globals.canvas.onmousedown = onMouseDown;
  globals.canvas.onmouseup   = onMouseUp;
  globals.canvas.ondblclick  = onDoubleClick;
  globals.canvas.onmousemove = onMouseMove;
  document.addEventListener('keydown', keyDownHandler);
  }


