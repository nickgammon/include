/*

Support functions, in Javascript, for the DTP system (see /hhs/dtp.php)


Copyright Â© 2019 Nick Gammon.

  Author: Nick Gammon <nick@gammon.com.au>
  Web:    http://www.gammon.com.au/
  Date:   November 2019

 PERMISSION TO DISTRIBUTE

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 and associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 LIMITATION OF LIABILITY

 The software is provided "as is", without warranty of any kind, express or implied,
 including but not limited to the warranties of merchantability, fitness for a particular
 purpose and noninfringement. In no event shall the authors or copyright holders be liable
 for any claim, damages or other liability, whether in an action of contract,
 tort or otherwise, arising from, out of or in connection with the software
 or the use or other dealings in the software.

  Note: The PHP file communicates with this module by passing down variables giving the element ID,
  element type and position of each element. The page width and page height are for converting from
  mm as used in the document and pixels as used on the screen.

  Example:

  var num_elements = 6;
  var page_width = 210;
  var page_height = 297;
  var grid_size_x = 8;
  var grid_size_y = 8;
  var elements = [
  [ 36, 3, 108, 48, 108, 280 ],
  [ 50, 6, 16, 96, 96, 152 ],
  [ 56, 6, 16, 216, 100, 268 ],
  [ 60, 5, 16, 16, 200, 40 ],
  [ 61, 5, 16, 48, 104, 212 ],
  [ 62, 7, 112, 48, 200, 288 ],
  ];

*/

const BOX_SIZE = 10;   // size of corner boxes
const DRAGGING_BOX_SIZE = 30;  // width of dragging box (height is BOX_SIZE)
const BOX_OPACITY = 1;
const BACKGROUND_OPACITY = 0.15;
const BACKGROUND_COLOUR = 'black';

// array position meanings (as generated by dtp.php)
const ELEMENT_ID    = 0;
const ELEMENT_TYPE  = 1;
const STARTX        = 2;
const STARTY        = 3;
const ENDX          = 4;
const ENDY          = 5;

const LAST_ITEM = ENDY;  // must be last element in array (above)

// element types
const ELEMENT_RECTANGLE         = 1;
const ELEMENT_ELLIPSE           = 2;
const ELEMENT_LINE              = 3;
const ELEMENT_STAR              = 4;
const ELEMENT_TEXT              = 5;
const ELEMENT_IMAGE             = 6;
const ELEMENT_TEXT_CONTINUATION = 7;

// for the page grid
const GRID_SIZE_X = 8;
const GRID_SIZE_Y = 8;

// Initialization: called on load of script
function init()
  {
  canvas = document.getElementById("mycanvas");  // our canvas

  if (canvas)
    {
    ctx = canvas.getContext("2d");                 // our drawing context
    // convert width from mm into pixels as displayed on the page
    width_multiple = canvas.width / page_width;
    height_multiple = canvas.height / page_height;

    // make a copy of element positions so we can reset to the beginning state
    orig_elements = [];
    for (i = 0; i < num_elements; i++)
      {
      orig_elements [i] = [];
      for (j = 0; j <= LAST_ITEM; j++)
        orig_elements [i] [j] = elements [i] [j];
      }
    } // end of if canvas exists

  // they haven't clicked the "Edit" button yet
  edit_clicked = false;
  edits_done = false;
  dragging = false;

  } // end of init

// draw one of the four corner boxes
function drawCornerBox (x, y)
  {
  ctx.beginPath();
  ctx.rect((x * width_multiple)   - BOX_SIZE / 2,
           (y * height_multiple)  - BOX_SIZE / 2,
           BOX_SIZE,
           BOX_SIZE
           );
  ctx.fillStyle = "green";
  ctx.globalAlpha = BOX_OPACITY;
  ctx.fill ();
  } // end of drawCornerBox

// fill with different colours to make the different elements stand out from each other
var movedFillColours = [
  'Red',
  'Green',
  'Blue',
  'Cyan',
  'Magenta',
  'Yellow',
  'Black',
];

// extract out one array element into global variables
function getElementDetails (element)
  {
  // extract out fields from database
  element_id    = element [ELEMENT_ID];
  element_type  = element [ELEMENT_TYPE];
  startX        = element [STARTX];
  startY        = element [STARTY];
  endX          = element [ENDX];
  endY          = element [ENDY];

  } // end of getElementDetails

// draw element borders, plus resizing and moving handles
function drawborders ()
{
ctx.clearRect(0, 0, canvas.width, canvas.height);  // clear canvas
for (i = 0; i < num_elements; i++)
  {
  // get *this* element
  getElementDetails (elements [i]);

  // stroke the entire element (box around it)
  ctx.beginPath();
  ctx.rect(startX * width_multiple, startY * height_multiple, (endX - startX) * width_multiple, (endY - startY) * height_multiple);

  // fill box if moved from original position
  if (ElementChanged (i))
    {
//    ctx.fillStyle = BACKGROUND_COLOUR;
    ctx.fillStyle = movedFillColours [i % movedFillColours.length];
    ctx.globalAlpha = BACKGROUND_OPACITY;  // low opacity fill
    ctx.globalAlpha = BACKGROUND_OPACITY * (Math.floor (i / movedFillColours.length) + 1);
    ctx.fill();
    }

  // now draw box around it
  ctx.strokeStyle = "green";
  ctx.globalAlpha = BOX_OPACITY;
  ctx.stroke();

  // corner boxes (small boxes at corners)
  drawCornerBox (startX, startY);

  // lines only have two corners
  if (element_type != ELEMENT_LINE)
    {
    drawCornerBox (endX, startY);
    drawCornerBox (startX, endY);
    }

  drawCornerBox (endX, endY);

  // draw dragging box
  ctx.beginPath();
  x = startX + ((endX - startX) / 2);  // half way along
  ctx.rect((x * width_multiple) - (DRAGGING_BOX_SIZE / 2),
           (startY * height_multiple)  - BOX_SIZE / 2,
           DRAGGING_BOX_SIZE,
           BOX_SIZE
           );
  ctx.globalAlpha = BOX_OPACITY;
  ctx.fillStyle = "green";
  ctx.fill ();

  } // end of for each element

} // end of drawborders

// helper function to reset one element back to its original position
function ResetOneElement (which)
  {

  // copy values back
  for (j = 0; j <= LAST_ITEM; j++)
    elements [which] [j] = orig_elements [which] [j];

  // put the HTML values back
  element_id = elements [which] [ELEMENT_ID];

  // fix up startX
  startXonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_startX"));
  startXonPage [0].value = elements [which] [STARTX];

  // fix up startY
  startYonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_startY"));
  startYonPage [0].value = elements [which] [STARTY];

  // fix up endX
  endXonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_endX"));
  endXonPage [0].value = elements [which] [ENDX];

  // fix up endY
  endYonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_endY"));
  endYonPage [0].value = elements [which] [ENDY];

  } // end of ResetOneElement

// here when the "Reset" button clicked - put everything back to how it was
function ResetClicked (event)
{
  submit_edits_button = document.getElementById("submit_edits_button");
  submit_edits_button.disabled = true;

  reset_edits_button = document.getElementById("reset_edits_button");
  reset_edits_button.disabled = true;

  // reset all elements
  for (i = 0; i < num_elements; i++)
    ResetOneElement (i);

  drawborders ();   // redraw original positions
  edits_done = false;
  return false;     // don't submit form
} // end of ResetClicked

// here when the "Edit" / "Submit edits" button is clicked
function SubmitEditsClicked (event)
{
  if (!edit_clicked)
    {
    edit_clicked = true;
    submit_edits_button = document.getElementById("submit_edits_button");
    submit_edits_button.value = "Submit edits";
    submit_edits_button.disabled = true;  // nothing edited yet
    drawborders ();
    return false;   // don't submit yet
    }
  return true;  // submit form now
} // end of SubmitEditsClicked

// returns true if this element has changed from its original position
function ElementChanged (which)
  {
  return elements [which] [STARTX] != orig_elements [which] [STARTX] ||
         elements [which] [ENDX]   != orig_elements [which] [ENDX] ||
         elements [which] [STARTY] != orig_elements [which] [STARTY] ||
         elements [which] [ENDY]   != orig_elements [which] [ENDY];
  } // end of ElementChanged

// see if the page has changed by checking all elements
function CheckIfPageChanged ()
  {
  changed = false;  // no changes yet

  // check each element
  for (i = 0; i < num_elements; i++)
    if (ElementChanged (i))
      changed = true;

  if (changed)
    {
    submit_edits_button.disabled = false;
    reset_edits_button.disabled = false;
    reset_edits_button.onclick = ResetClicked;
    edits_done = true;
    }
  else
    {
    // no changes? make sure submit and reset buttons are disabled
    // - this is for the situation where you make a change and then change it back
    submit_edits_button.disabled = true;
    reset_edits_button.disabled = true;
    reset_edits_button.onclick = null;
    edits_done = false;
    }
  } // end of CheckIfPageChanged

// set the appropriate mouse cursor shape depending on what it is hovering over, if anything
function SetMouseCursor (event)
  {
  mousex = event.offsetX;
  mousey = event.offsetY;

  // find active element, assuming we can see them (edit button has been clicked)
  if (edit_clicked)
    {
    for (i = 0; i < num_elements; i++)
      {
      activeElement = i;
      // get *this* element
      getElementDetails (elements [i]);
      // top left?
      if (mouseInBox (mousex, mousey, startX, startY, BOX_SIZE, BOX_SIZE))
        {
        canvas.style.cursor = 'nwse-resize';
        return;
        }
      // top right?
      else if (mouseInBox (mousex, mousey, endX, startY, BOX_SIZE, BOX_SIZE) && element_type != ELEMENT_LINE)
        {
        canvas.style.cursor = 'nwse-resize';
        return;
        }
      // bottom left?
      else if (mouseInBox (mousex, mousey, startX, endY, BOX_SIZE, BOX_SIZE) && element_type != ELEMENT_LINE)
        {
        canvas.style.cursor = 'nwse-resize';
        return;
        }
      // bottom right?
      else if (mouseInBox (mousex, mousey, endX, endY, BOX_SIZE, BOX_SIZE))
        {
        canvas.style.cursor = 'nwse-resize';
        return;
        }
      // and now check the dragging box
      else if (mouseInBox (mousex, mousey, startX + (endX - startX) / 2, startY, DRAGGING_BOX_SIZE, BOX_SIZE))
        {
        canvas.style.cursor = 'move';
        return;
        }
      } // end of for each element
    }   // of edit button active

  // edit button or not, we can double-click elements

  // check the entire element rectangle
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (i = num_elements - 1; i >= 0; i--)
    {
    activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    if (mousex < (startX * width_multiple))
      continue;  // too far left
    if (mousex > (endX * width_multiple))
      continue;  // too far right
    if (mousey < (startY * height_multiple))
      continue;  // too far up
    if (mousey > (endY * height_multiple))
      continue;  // too far down

    // found the element!
    canvas.style.cursor = 'pointer';
    return;
    } // end of for each element

  // mouse isn't anywhere interesting
  canvas.style.cursor = 'default';

  } // end of SetMouseCursor

// mouse move handler - resize the element box (or move it) assuming we had a previous mouse down
function onMouseMove(event)
{
  mousex = event.offsetX;
  mousey = event.offsetY;

  // if dragging (mouse down previously) update the element's position depending on where we move to
  if (dragging)
   {
    // find new position in mm
    x = Math.round(mousex / width_multiple);
    y = Math.round(mousey / height_multiple);

    // shift key snaps to the grid
    if (event.shiftKey)
      {
      x = Math.round(x / grid_size_x) * grid_size_x;
      y = Math.round(y / grid_size_y) * grid_size_y;
      }

    element_type = elements [activeElement] [ELEMENT_TYPE];

    // update element - depending on which corner was being moved

    // top left
    if (activeCorner == 'topleft' && element_type == ELEMENT_LINE)
      {
      // lines can line up vertically and horizontally
      if (x <= elements [activeElement] [ENDX] && y <= elements [activeElement] [ENDY])
        {
        elements [activeElement] [STARTX] = x;
        elements [activeElement] [STARTY] = y;
        }
      }
    else if (activeCorner == 'topleft' && element_type != ELEMENT_LINE)
      {
      if (x < elements [activeElement] [ENDX] && y < elements [activeElement] [ENDY])
        {
        elements [activeElement] [STARTX] = x;
        elements [activeElement] [STARTY] = y;
        }
      }

    // top right
    else if (activeCorner == 'topright')
      {
      if (x > elements [activeElement] [STARTX] && y < elements [activeElement] [ENDY])
        {
        elements [activeElement] [ENDX] = x;
        elements [activeElement] [STARTY] = y;
        }
      }

    // bottom left
    else if (activeCorner == 'bottomleft')
      {
      if (x < elements [activeElement] [ENDX] && y > elements [activeElement] [STARTY])
        {
        elements [activeElement] [STARTX] = x;
        elements [activeElement] [ENDY] = y;
        }
      }

   // bottom right
   else if (activeCorner == 'bottomright' && element_type == ELEMENT_LINE)
      {
      // lines can line up vertically and horizontally
      if (x >= elements [activeElement] [STARTX] && y >= elements [activeElement] [STARTY])
        {
        elements [activeElement] [ENDX] = x;
        elements [activeElement] [ENDY] = y;
        }
      }
   else if (activeCorner == 'bottomright' && element_type != ELEMENT_LINE)
      {
      if (x > elements [activeElement] [STARTX] && y > elements [activeElement] [STARTY])
        {
        elements [activeElement] [ENDX] = x;
        elements [activeElement] [ENDY] = y;
        }
      }

    // drag box (reposition)
    else if (activeCorner == 'drag')
      {
      deltaX = Math.round((dragMouseX - event.offsetX) / width_multiple);
      deltaY = Math.round((dragMouseY - event.offsetY) / height_multiple);

      new_x = dragStartX - deltaX;
      new_y = dragStartY - deltaY;
      width = elements [activeElement]  [ENDX] - elements [activeElement] [STARTX];
      height = elements [activeElement] [ENDY] - elements [activeElement] [STARTY];

      // shift key snaps to the grid
      if (event.shiftKey)
        {
        new_x = Math.round(new_x / grid_size_x) * grid_size_x;
        new_y = Math.round(new_y / grid_size_y) * grid_size_y;
        }

      elements [activeElement] [STARTX] = new_x;
      elements [activeElement] [STARTY] = new_y;
      elements [activeElement] [ENDX]   = new_x + width;
      elements [activeElement] [ENDY]   = new_y + height;
      }

    drawborders ();

    // update form ready for them to post it

    // turn element array number into an element ID
    element_id = elements [activeElement] [ELEMENT_ID];

    // fix up startX
    startXonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_startX"));
    startXonPage [0].value = elements [activeElement] [STARTX];

    // fix up startY
    startYonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_startY"));
    startYonPage [0].value = elements [activeElement] [STARTY];

    // fix up endX
    endXonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_endX"));
    endXonPage [0].value = elements [activeElement] [ENDX];

    // fix up endY
    endYonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_endY"));
    endYonPage [0].value = elements [activeElement] [ENDY];

    submit_edits_button = document.getElementById("submit_edits_button");
    reset_edits_button = document.getElementById("reset_edits_button");

    // check a change has actually been made before activating the submit and reset buttons
    CheckIfPageChanged ();
    return;
   }  // if dragging

  // MOUSE CURSOR CHANGES

  // if not dragging, change the mouse to indicate what we *can* do if we click
  SetMouseCursor (event);

} // end of onMouseMove

// test if the mouse is inside one of the dragging boxes
function mouseInBox (mousex, mousey, x, y, hsize, vsize)
  {
  if (mousex < (x * width_multiple) - hsize / 2)
    return false;  // too far left
  if (mousex > (x * width_multiple) + hsize / 2)
    return false;  // too far right
  if (mousey < (y * height_multiple) - vsize / 2)
    return false;  // too far up
  if (mousey > (y * height_multiple) + vsize / 2)
    return false;  // too far down
  return true;
  } // end of mouseInBox

// mouse down event - set up for dragging somewhere
function onMouseDown(event)
{
  found = false;
  mousex = event.offsetX;
  mousey = event.offsetY;

  // mouse down isn't active until we can see the handler boxes
  if (!edit_clicked)
    return;

  // find active element
  for (i = 0; i < num_elements; i++)
    {
    activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);
    // top left?
    if (mouseInBox (mousex, mousey, startX, startY, BOX_SIZE, BOX_SIZE))
      {
      activeCorner = 'topleft';
      found = true;
      break;
      }
    // top right?
    else if (mouseInBox (mousex, mousey, endX, startY, BOX_SIZE, BOX_SIZE) && element_type != ELEMENT_LINE)
      {
      activeCorner = 'topright';
      found = true;
      break;
      }
    // bottom left?
    else if (mouseInBox (mousex, mousey, startX, endY, BOX_SIZE, BOX_SIZE) && element_type != ELEMENT_LINE)
      {
      activeCorner = 'bottomleft';
      found = true;
      break;
      }
    // bottom right?
    else if (mouseInBox (mousex, mousey, endX, endY, BOX_SIZE, BOX_SIZE))
      {
      activeCorner = 'bottomright';
      found = true;
      break;
      }
    // and now check the dragging box
    else if (mouseInBox (mousex, mousey, startX + (endX - startX) / 2, startY, DRAGGING_BOX_SIZE, BOX_SIZE))
      {
      activeCorner = 'drag';
      // remember where we clicked so we can get a delta location
      dragMouseX = mousex;
      dragMouseY = mousey;
      // remember where it was when we clicked
      dragStartX = elements [activeElement] [STARTX];
      dragStartY = elements [activeElement] [STARTY];
      dragEndX   = elements [activeElement] [ENDX];
      dragEndY   = elements [activeElement] [ENDY];
      found = true;
      break;
      }

    } // end of for each element

  if (!found)
    return;

  if (activeCorner == 'drag')
    canvas.style.cursor = 'move';
  else
    canvas.style.cursor = 'nwse-resize';

  dragging = true;

  document.getElementById('editing_notes').innerHTML = 'SHIFT to snap to grid, CTRL to reset position.';

} // end of onMouseDown

// mouse up handler - cancel ability to drag
function onMouseUp(event)
  {

  // ctrl key means discard moves and reset to defaults
  if (dragging && event.ctrlKey && activeCorner)
    {
    ResetOneElement (activeElement);  // put the current element back to its default position
    CheckIfPageChanged ();
    drawborders ();     // redraw page
    }

  activeCorner = '';
  dragging = false;
  document.getElementById('editing_notes').innerHTML = '';
  SetMouseCursor (event);
  } // end of onMouseUp

// double-click in an element box edits that element (eg. to change the text)
function onDoubleClick(event)
  {
  mousex = event.offsetX;
  mousey = event.offsetY;

  if (edits_done)
    {
    alert ("You have un-saved position edits - submit them or reset them.");
    return;
    }

  // check the dragging boxes first in case a small element is inside a larger one
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (i = num_elements - 1; i >= 0; i--)
    {
    activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    // let them double-click in the title box in case it is hard to find the element (eg. a line)
    if (mouseInBox (mousex, mousey, startX + (endX - startX) / 2, startY, DRAGGING_BOX_SIZE, BOX_SIZE))
      {
      button_to_click = document.getElementById("link_to_edit_element_".concat (element_id));
      if (!button_to_click)
        return;   // can't find button
      button_to_click.click();    // activate it
      return;
      }
    } // end of for each element

  // now check the entire element rectangle
  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (i = num_elements - 1; i >= 0; i--)
    {
    activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    if (mousex < (startX * width_multiple))
      continue;  // too far left
    if (mousex > (endX * width_multiple))
      continue;  // too far right
    if (mousey < (startY * height_multiple))
      continue;  // too far up
    if (mousey > (endY * height_multiple))
      continue;  // too far down

    // found the element!
    button_to_click = document.getElementById("link_to_edit_element_".concat (element_id));
    if (!button_to_click)
      return;   // can't find button

    button_to_click.click();    // activate it
    return;
    } // end of for each element

  } // end of onDoubleClick

// START HERE

init ();  // get our canvas and context

if (canvas)
  {
  // mouse handlers
  canvas.onmousedown = onMouseDown;
  canvas.onmouseup   = onMouseUp;
  canvas.ondblclick  = onDoubleClick;
  canvas.onmousemove = onMouseMove;
  }

/*

These lines are added by the PHP file once the "submit_edits_button" button exists,
otherwise the onclick doesn't work.

    submit_edits_button = document.getElementById(\"submit_edits_button\");
    submit_edits_button.onclick = SubmitEditsClicked;

*/
